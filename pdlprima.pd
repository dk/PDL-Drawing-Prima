# These are for THIS PD FILE (as opposed to the same code 10 lines
# below, which applied to the generated module file).
use strict;
use warnings;
use Carp qw(croak confess);

#our $PP_VERBOSE = 1;

pp_addpm({At=>'Top'},<<'ModuleMaterial');

BEGIN { 
$VERSION = '1.00'; 
} 

use strict;
use warnings;
use PDL;
use PDL::Char;
use Scalar::Util 'blessed';
use Carp 'croak';

# working here - use Exporter and set as 'EXPORT_OK' the functions
# pdl_of_patterns_for and pdl_of_handles_for. Their usage looks like this:
#  my $patterns = pdl_of_patterns_for($pat1, $pat2, ...);
#  my $handles  = pdl_of_handles_for($widget1, $widget2, ...);

=head1 NAME

PDL::Drawing::Prima - PDL-aware drawing functions for Prima widgets

=cut

ModuleMaterial

=head1 CPAN

You, gentle reader, are reading this documentation off of CPAN. I know this
because B<this> documentation does not show up in the final .pm files that are
installed on a user's computer. I have gone to great lengths to ensure that
the CPAN-visible documentation is up-to-date, but it may be incomplete in
certain circumstances since PDL autogenerates some of its documentation. If
you have any concerns regarding documentation skew, be sure to check the
documentation on your local machine.

=cut

# working here - what about lineJoin or lineEnd? These should be applicable to
# the line drawing routines?

pp_addpm({At=>'Top'},<<'ModuleMaterial');

=head1 SYNOPSIS

Each of the methods comes with a small sample snippet. To see how it
looks, copy this synopsis and replace the code in the
C<Example code goes here> block with the example code.

 use strict;
 use warnings;
 use PDL;
 use PDL::Drawing::Prima;
 use Prima qw(Application);
 
 my $window = Prima::MainWindow->create(
     text    => 'PDL::Drawing::Prima Test',
     onPaint => sub {
         my ( $self, $canvas) = @_;
 
         # wipe the canvas:
         $canvas->clear;
         
         ### Example code goes here ###
         
         # Draw a sine curve on the widget:
         my ($width, $height) = $canvas->size;
         my $x = sequence($width);
         my $y = ( sin($x / 20) + 1 ) * $height/2;
         $canvas->pdl_polylines($x, $y, lineWidths => 2);
         
         ### Example code ends here ###
     },
     backColor => cl::White,
 );
 
 run Prima;

=head1 DESCRIPTION

This is a set of PDL bindings to the Prima raster drawing functions. At the
moment, only drawing to displayed widgets is supported. I would like to add
postscript support, but that's a little ways off yet.

Most of the functions given here are PDLified versions of the Prima drawing API
functions, which are documented under L<Prima::Drawable>. In general, where the
Prima API uses singular nouns, I here use plural nouns.

=head1 COORDINATE ORIGIN

The Prima image coordinate origin is located in lower left corner, which is
where you would expect to find it when creating plots. However, it is different
from the way that many graphics libraries do their coordinates.

=head1 FUNCTIONS

=head2 piddle_of_patterns_for

If you want PDL to thread over line patterns, but you want to use the standard
Prima line patterns, you'll need to convert them line patterns to a piddle.
This works very simply like this:

 my $patterns = piddle_of_patterns_for(lp::Solid, lp::Dash);

This creates a piddle with the two patterns so that you could have PDL thread
over them.

You can also create your own line pattern piddles by hand. I recommend you use
byte array, since otherwise it will be converted to byte arrays for you.
The first element of a row in your byte array
specifies the number of pixels to be "on", the second specifies the number to be
"off", the third specifies the number to be "on" again, the fourth "off", the
fifth "on", etc. If that doesn't make sense, hopefull a couple of examples will
help clarify.

This example creates the equivalent of lp::Dash:

 my $dash_pattern = byte (9, 3);

This example creates a piddle with four line types: lp::Solid, lp::Dash,
lp::ShortDash, and lp::DashDot:
 
 my $patterns = byte q[ 1; 9 3; 3 3; 9 3 1 3];

and should be identical to

 my $patterns = piddle_of_patterns_for(
     lp::Solid, lp::Dash, lp::ShortDash, lp::DashDot);
 
When you create a byte piddle, all of the patterns must have the same number of
bytes in their specification. Of course, different patterns have different
lengths, so in that case simply pad the shorter specifications with zeroes.

=cut

# Builds a piddle of patterns with the appropriate sizes, etc.
sub piddle_of_patterns_for {
	# Make sure they're not being stupid:
	croak("You must supply at least one pattern to make a pattern piddle")
		if @_ == 0;

	# First get the longest pattern:
	my $length = 0;
	foreach(@_) {
		$length = length($_) if $length < length($_);
	}
	
	use PDL::NiceSlice;
	
	# Create the new byte array with the appropriate dimensions:
	my $to_return = zeroes(byte, $length, scalar(@_));
	$to_return .= $to_return->sequence;
	for (my $i = 0; $i < @_; $i++) {
		# Get a slice and update it:
		my $slice = $to_return(:,$i);
		substr ${$slice->get_dataref}, 0, length($_[$i]), $_[$i];
		
		# Make sure the modifications propogate back to the original:
		$slice->upd_data;
	}
	
	no PDL::NiceSlice;
	
	return $to_return;
}

=head2 piddle_of_handles_for

You can call a single drawing function on multiple widgets and have PDL thread
over the widgets for you. I cannot conceive of why you might commonly want to do
this, but I can think of a couple of rare use cases, so I've implemented it. In
order to work with multiple widgets in a single function call, you'll need to

=cut

sub piddle_of_handles_for {
	# Make sure they're not being stupid:
	croak("You must supply at least one widget from which to get a handle")
		if @_ == 0;
	
	# Make sure all of the variables are indeed widgets:
	foreach(@_) {
		croak("One or more of your widgets does not seem to be descended from Prima::Drawable")
			unless blessed($_) and $_->isa('Prima::Drawable');
	}
	
	# Make a piddle large enough to hold the handles:
	my $to_return = zeroes(long, scalar(@_));
	
	# put the handles in the piddle:
	_piddle_of_handles_for(${$to_return->get_dataref}, @_);
	
	# Update the piddle and return it:
	$to_return->upd_data;
	return $to_return;
}

=head1 METHODS

The methods described below are a bit unusual for PDL functions. First, they are
not actually PDL functions at all but are methods for C<Prima::Drawable>
objects. Second, their signatures will look a bit funny. Don't worry too much
about that, though, because they will resemble normal signatures close enough
that you should be able to understand them, I hope.

=cut

ModuleMaterial

pp_addxs('', q{
void
_piddle_of_handles_for(SV * piddle_SV, ...)
	CODE:
		int i;
		/* Get at the piddle's actual data array */
		long * piddle = (long*)SvPVX(piddle_SV);
		/* Fill the array with the handle values */
		for (i = 1; i < items; i++) {
			piddle[i-1] = gimme_the_mate(ST(i));
		}

});
=for details
As far as I can tell, PDL::PP only defines the '_<func>_int' form of a function
when you specify a PMCode in the pp_def. I can't figure out where this happens
in PP.pm, but that appears to be the output behavior. For an introduction to
postscript, see http://local.wasp.uwa.edu.au/~pbourke/dataformats/postscript/
and http://www.physics.emory.edu/~weeks/graphics/howtops1.html

=cut

pp_addhdr( <<HEADER );

/* apricot is the (strangely named) header file that contains all of the
 * cross-platform functions.
 */

#undef WORD
#include <apricot.h>
#define MY_BIG_NUMBER 1000000

HEADER

#######################################################################
#                              Machinery                              #
#######################################################################

=begin details

=head1 Complex parameter handling

Each of the functions in this module wrap a PDL function around the
Prima API. The goal of the PDL functions is to allow the caller to
provide as many or as few tweaks to their drawing as they wish, so if
they want to draw three different polylines with three different line
styles, they should be able to do this:

 $widget->pdl_polylines($xs, $ys, {linePatterns => $patterns});

and it will DWIM. That means that the PP functions have to (1) get all
the possible preferences in as parameters (preferably piddles), (2) the
PP functions have to call the appropriate functions from apricot.h
to do their work, and (3) the PP functions have to package their piddles
in a form that the apricot.h functions know how to handle. To make
matters even more complicated, different API functions pay attention to
different properties, so different ones apply for different functions!

To deal with all of this, the next 400 or so lines of code create some
machinery that greatly assists in building the pp_defs that follow. A
great deal of this code is used in THIS script (.pd files are actually
scripts that generate .xs and .pm files) to assist in generating code.
Anything that needs to end up in the *output* files will be quoted, so
hopefully your syntax highlighter will help you pick them apart.

=end details

=cut

###################################################
# Creating the look-up table for the Pars section #
###################################################

=begin details

This hash translates from a simple parameter name to a PDL signature.
Without this hash, if I wanted to write a function that allows the user
to draw lines with different colors, I would write the following Pars:

  Pars => 'int x(n); int y(n); int colors()'

So in the hash below, the property C<colors> is associated with the
arg string C<int colors()>, and (not-optional, but specially processed)
C<handles> property is associated with the arg string C<int handles()>.

=end details

=cut

my %pars_args_for = (colors => 'int colors()'
	, handles => 'int handles()'
);

=begin details

At the moment, I only have the colors property. If you know the Prima
Drawable API, you'll know I'm missing a lot! This is because I will
build up a number of structures over this discourse and I would
like to keep the code and specifications for each property in one place.
Scroll down to the 'Assembling machinery' portion of this code, about
175 lines below, and you'll see all the parts for each of the Drawable
properties defined in one place.

=end details

=cut

#########################
# Generating Pars lists #
#########################

=begin details

This function creates a string with the low-level PDL function's argument
list, given a list of properties for the function. This makes it very
easy to manage long parameter lists, and long parameter lists are nicely
handled by the in-pm function C<get_sorted_args_with_defaults>. It also
adds handles to the signature, which is mandatory for each of these
functions. To expand on the previous example, in this code:

 pp_def('my_func',
        Pars => 'int x(n); int y(n); ' . generate_pars_args_for( 'colors', 'rops'),
        ...
 );

pp_def sees a parameter list that looks like this:

 'int x(n); int y(n); int handles(); int colors(); int rops()'

To use this, I will create a list of properties that the to-be-defined
function takes, and use that together with generate_pars_args_for like
so:

 my @clear_properties = qw(backColors rop2s);
 pp_def('prima_clear',
        Pars => 'int x1(); int y1(); int x2(); int y2(); '
                 . generate_pars_args_for(@clear_properites),
        PMCode => ...
 );

It may seem silly to use such an array for only two additional arguments
(as shown in this example), but other parts of the pp_def call will make
use of that array, as we will see, and most of the functions use many
more properties.

=end details

=cut

sub generate_pars_args_for {
	foreach (@_) {
		croak("Bad args; should be plural") unless /s$/;
	}
	return join('; ', @pars_args_for{'handles', @_});
}

######################################
# Property-dependent local variables #
######################################

=begin details

As already mentioned, many of the properties that could potentially be
sent to the drawing apricot.h functions will need a set of local
variables. Currently, clipRects and linePatterns need special variables
to do their work, and these variables should be created outside the
threadloop. (regions, when implemented, may need to use this, too.)
Functions that do not care about those properties will not need those
variables, so they should only be included in functions that actually
use them. generate_init_args_for handles this code generation, taking
the same array of properties used by generate_pars_args_for. See the
next section for an example of use.

Note that entries in C<%init_args_for> should be semi-colon seperated,
since they are C declarations, but the last entry should not have a 
semi-colon. One will be appended. This is to keep consistency with
C<%pars_args_for>, which has the same format.

=end details

=cut

my %init_args_for = ();

sub generate_init_args_for {
	my $to_return = "\t\t/* These are declarations needed for the handles
		 * and some of the optional parameters */
		 Handle widget_handle;\n";
		 
	# Build the list:
	foreach(@_) {
		$to_return .= "\t\t$init_args_for{$_};\n"
			if exists $init_args_for{$_};
	}
	
	return $to_return;
}

##########################################
# Tracking which properties need setting #
##########################################

=begin details

The only way to determine from within PP code whether an optional
parameter was passed in or not is to pass an additional structure to
the PP code with that information. The structure I use for this is
the original hash passed in as
an argument to the Perl-level function. If the user specified a value
for a property, it will be present in the hash. If they did not, it will
not be there.

So, for each of the graphics properties that the user can supply for a
given function, I will want to have code in the PP Code section that
looks something like this:

 SV* arg_hash_HV = SvRV(arg_rev_sv);
 int is_setting_rops;
 is_setting_rop = hv_exists_ent(arg_hash_hv, sv_2mortal(newSVpv("rops", 0)), 0);

This code checks if the key "rops" exists in the arg_hash_hv hash (which
must be passed in to the PP function via OtherPars). The
return value is a boolean, which I will use in the threadloop. Looking
up these values once and storing their results will make the resulting
code much less cluttered, and hopefully faster.

Here's a function that generates the code for me, based on the supplied
list of properties. It's a little different from the example above, but
they basically do the same thing. It, too, uses the same array of
properties used by generate_pars_args_for. The auto-generated code from
this function is inserted directly into the Code key in the pp_def
function call, like so:

 my @func_pars = qw(backColor linePattern);
 pp_def('my_func',
     Pars => 'int arg1(n); ' . generate_pars_args_for(@func_pars),
     ...
     Code => q{
         /* set-up variables I will need throughout the threadloop */
         int alpha;
     } . generate_init_args_for(@func_pars)
       . create_boolean_setters_for(@func_pars)
     . q{
         alpha = -1;
         ... 
         threadloop %{
             ...
         %}
     },

=end details

=cut

sub create_boolean_setters_for {
	# Make sure I handle an empty list correctly. I can't imagine
	# calling this function with an empty list, but let's be safe:
	return '' unless @_;
	# This is the string I will build up for my return value:
	my $to_return = "
		/* The last of the declarations */
		SV* key;
		HV* arg_hash_hv;
		int ";
	# Create the variable list (is_setting_colors, is_setting_lineWidths...):
	$to_return .= join(', ', map {"is_setting_$_"} @_) . ";\n";
	
	# Set the variables:
	$to_return .= "
		/* Begin initializing the values */
		key = sv_newmortal();
		arg_hash_hv = (HV*)SvRV(\$COMP(arg_ref_sv));
";
	foreach(@_) {
		$to_return .= "\t\tsv_setpv(key, \"$_\");\n"
					. "\t\tis_setting_$_ = hv_exists_ent(arg_hash_hv, key, 0);\n";
	}
	return $to_return;
}

####################################
# Creating the initialization code #
####################################

=begin details

I've built up a lot of machinery to handle the various required arguments
and optional properties. This next chunk of code gives a single function
that will call everything in the proper order to declare and initialize
the necessary variables, early within the Code section.

=end details

=cut

sub initialize_for {
	my @properties = @_;
	return '
		/* BEGIN AUTOGENERATED INITIALIZATION */

	' . generate_init_args_for(@properties)
	  . create_boolean_setters_for(@properties) . '
		
		/* END AUTOGENERATED INITIZLIATION */
	';
}

my $default_other_pars = 'SV * arg_ref_sv';

#################################
# Calling the apricot.h setters #
#################################

=begin details

Each of the setters needs to first check if its call is even necessary
(using the boolean variables set-up in the previous section),
and then it needs to call the appropriate setter from apricot.h. This is
easy but repetitive code, so once again I generate it from the same
list of arguments as everything else. In what follows, I create a
function that generates these code fragments for me, or looks them up
in a hash if they're complicated. Note that the function wraps the
looked-up code in its own curly-braced block; all you need to write is
the code itself like the following colors example shows:

The auto-generated code for this section is inserted directly into the
Code key in the pp_def function call, within the threadloop, before the
apricot function for this function is itself called. For example:

 q[
     ...
     threadloop %{
		 /* Apply any per-threadloop tweaks */
         ] . generate_setter_code_for(@func_pars)
         . q[
         /* Call the apricot function */
         apc_gp_set_func(args);
     %}
 ]

=end details

=cut

my %set_code_for = (
	colors => q{
				/* cast the integer as a Colors type (which itself is a
				 * 32-bit int, so maybe this is unnecessary */
				apc_gp_set_color(widget_handle, (Color)$colors());
},
);

sub generate_single_setter_code_for {
	my $property = shift;
	# Make the singular name from the plural:
	(my $singular = $property) =~ s/s$//;
	# apricot uses underscores and all lowercase instead of CamelCase:
	(my $apricot  = $singular) =~ s/([A-Z])/_\l$1/g;
	# Build the return string:
	my $to_return = "\t\t\tif (is_setting_$property) {\n";
	if (exists $set_code_for{$property}) {
		# Insert special handling code:
		$to_return .= $set_code_for{$property};
	}
	else {
		# Most other properties are direct sets:
		$to_return .= "\t\t\t\tapc_gp_set_$apricot(widget_handle, \$$property());\n";
	}
	
	$to_return .= "\t\t\t}";
}

# working here - I think I need to create a hash like %bad_check_code_for
# to handle per-property bad checking code
sub generating_bad_single_setter_code_for {

}

sub generate_setter_code_for {
	return "
			widget_handle = (Handle)\$handles();
			/* BEGIN AUTOGENERATED SETTER CHECKS */\n"
			. join("\n", (map {generate_single_setter_code_for($_)} @_)) . "
			/* END AUTOGENERATED SETTER CHECKS */\n";
}

##################################################
# Building machinery for the different properies #
##################################################

=begin details

Now that I have all of the infrastructure ready, I need to build up the
data structures for each of the properties.

=end details

=cut

# Background color:
$pars_args_for{backColors} = 'int backColors()';
$set_code_for{backColors} = q{
				/* cast the integer as a Colors type (actually an int) */
				apc_gp_set_back_color(widget_handle, (Color)$backColors());
};

# Clipping rectangle:
$pars_args_for{clipRects} = 'int clipLeft(); int clipBottom(); int clipRight(); int clipTop()';
$init_args_for{clipRects} = 'Rect clip_rect';
$set_code_for{clipRects} = q{
				clip_rect.left = $clipLeft();
				clip_rect.bottom = $clipBottom();
				clip_rect.right = $clipRight();
				clip_rect.top = $clipTop();
				apc_gp_set_clip_rect(widget_handle, clip_rect);
};

# These do no need any special args, and the default generated code will
# work just fine:
$pars_args_for{lineEnds} = 'int lineEnds()';
$pars_args_for{lineJoins} = 'int lineJoins()';
$pars_args_for{lineWidths} = 'int lineWidths()';
$pars_args_for{rops} = 'int rops()';
$pars_args_for{rop2s} = 'int rop2s()';

# line patterns. This code has to cast the byte piddle into a char and
# send that and the length to the line_pattern function.
$pars_args_for{linePatterns} = 'byte linePatterns(patlen)';
$init_args_for{linePatterns} = 'unsigned char * pattern; int pattern_length';
$set_code_for{linePatterns} = q{
				pattern = (unsigned char *)$P(linePatterns);
				pattern_length = strlen(pattern);
				apc_gp_set_line_pattern(widget_handle, pattern, pattern_length);
};

# translation; the apricot function for translate uses a different name
# and takes two arguments instead of one:
$pars_args_for{translates} = 'int trans_x(); int trans_y()';
$set_code_for{translates} = q{
				/* invoke the apricot function with both x and y */
				apc_gp_set_transform(widget_handle, $trans_x(), $trans_y());
};

# Fill winding works nicely without any alteration:
$pars_args_for{fillWindings} = 'int fillWindings()';

# Fill pattern will may work nicely without any alteration, but I am
# going to be explicit and cast the fillPattern piddle into a U8 array:
$pars_args_for{fillPatterns} = 'byte fillPatterns(oct=8)';
$set_code_for{fillPatterns} = q{
			/* Casts the pattern as a U8 pointer and continues */
			apc_gp_set_fill_pattern(widget_handle, (U8*)$P(fillPatterns));
};

# Spline precision works well with the default setup:
$pars_args_for{splinePrecisions} = 'int splinePrecisions()';

# Ignoring for now: region
# The underlying graphics functions explicitly operate with a 1-bit-per-pixel
# Prima::Image bitmap. I could use PDL::PrimaImage as the argument, but
# that seems like a lot of repackaging for every round in the PP
# threadloop. Alternatively, I could take an array ref with Prima::Image
# objects as the argument, and simply cycle through that.


#######################################################
# Argument processing, ordering, and default handling #
#######################################################

=begin details

Each of the perl-side functions that gets invoked as an object
method checks its arguments. It does this by analyzing the hash sent in
by the caller, checking for properties that don't belong, or were
mis-spelled, and repackaging the results into a list with the exact
order needed by the PP code. Most parameters take a single piddle as
their argument, but some don't. This code needs to know how many
arguments go with each parameter, so it can check that, too. Such a list
of parameters can be automatically constructed from the already-defined
%pars_args_for hash.

=end details

=cut

pp_addpm (join("\n"
	, '# This is a list of the number of arguments for each property. It is based on the'
	, '# pars_args_for hash which is built in the .pd file associated with this module'
	, 'my %N_args_for = qw('
	# Note that the tr operator, as used, just counts the number of semi-colons
	# in the pars args associated with the property.
	, (map {sprintf "\t%-20s %d", $_, ($pars_args_for{$_} =~ tr/;//) + 1}
		(keys %pars_args_for))
	, ');'
	)
);

=begin details

Having collected the number of arguments associated with each of the
properties, I need a function to actually process the hash.
This is a function that I call in all of my PMCode sections. It takes an
anonymous list of names and an anonymous hash. If the hash has a key for
one of the names, it includes that in the return list. If it doesn't, it
returns the default value of a 0-dim piddle with value 0. If one of the
hash keys is not in the list of names, it croaks.

Put a little differently, this function takes an anonymous hash, makes
sure there are no extraneous arguments, extracts the desired arguments
or uses a sensible default, and returns the arguments in the desired
order.

=end details

=cut

pp_addpm <<'DefaultArgumentHandling';

sub get_sorted_args_with_defaults {
	my ($self, $arg_names, $given) = @_;
	
	# Default to an empty list:
	$given = {} unless ref($given) eq 'HASH';
	
	# Copy the arg_names array, so I can add 'handles' to it without
	# effecting the original array:
	my @arg_names = @$arg_names;
	unshift @arg_names, 'handles';
	
	# Check that they supplied only allowed parameters:
	foreach (keys %$given) {
		croak("Unknown parameter $_") unless $_ ~~ @$arg_names
	}
	
	# Create a 0-dim piddle with this object's hande in it:
	my $handle = piddle_of_handles_for($self);
	
	# Return the sorted list of supplied or default values
	my @to_return = ();
	foreach ('handles', @$arg_names) {
		# If not specified, return a default property of a zero-dim
		# piddle. Except for the handles, the value doesn't matter
		# because it is never used. For handles, the value should revert
		# to the calling widget's handle:
		if (not exists $given->{$_}) {
			push @to_return, ($handle) for (1..$N_args_for{$_});
		}
		elsif (ref ($given->{$_}) eq 'ARRAY') {
			# If an array ref, dereference it and make sure the number
			# of arguments agrees with what we expect:
			if (@{$given->{$_}} != $N_args_for{$_}) {
				croak("Expected 1 argument for $_") if $N_args_for{$_} == 1;
				croak("Expected $N_args_for{$_} arguments for $_");
			}
			push @to_return, @{$given->{$_}};
		}
		else {
			# Otherwise, return it outright, if we only expected one
			# argument:
			$N_args_for{$_} == 1
				or croak("Expected $N_args_for{$_} arguments for $_");
			
			push @to_return, $given->{$_};
		}
	}
	return @to_return;
}

DefaultArgumentHandling


###################################
# Generating PMCode automatically #
###################################

=begin details

The PMCode section of each of these is pretty much the same. This
snippet of code generates that code for me. It takes the names of the
arguments and returns the autogenerate PMCode.

This code is very dense. I hope that it is documented well enough with
comments that any future maintainer will be able to understand it. If
in doubt, this function operates stand-alone, so you can copy it into
a little test script and try calling it with sample parameters to get a
feel for how it behaves.

working here - I have a few argument checking
ideas for this function, including
considering checking that C<$self> is a Prima::Drawable type, but not
Prima::PS::Drawable. Also, I bet if PDL barfs, it'll point to the line
in the (generated) pm file, so the pdl function call should probably be
wrapped in an eval block, and $@ should be post-processed.

=end details

=cut

sub generate_PMCode_for {
	my ($func_name, $props, @arg_names) = @_;
	my $props_array_name = '@' . $func_name . '_props';
	my $args_array_name = '@' . $func_name . '_args';
	# Outside the function definition, create the list of properties
	# that this function uses, as well as the names of the arguments.
	# It needs these lists in the actual Perl module file so it can
	# check the passed arguments and provide meaningful error messages:
	my $to_return = "our $props_array_name = qw(@$props);\n"
				. "our $args_array_name = qw(@arg_names);\n";
	
	# Define the drawable function in the Prima::Drawable namespace
	# and check for arguments:
	$to_return .= "sub Prima::Drawable::pdl_$func_name {
	# Before anything else, make sure they supplied at least the
	# required number of arguments:
	croak('pdl_$func_name expectes '. scalar($args_array_name)
		. ' arguments (and the widget): ' . join(', ', 'widget', $args_array_name))
		unless (\@_ > $args_array_name);

	# unpack the widget and the required arguments for this function:
";
	foreach ('self', @arg_names) {
			$to_return .= "\tmy \$$_ = shift;\n";
	}
	$to_return .= "
	# Check for an even number of remaining arguments (key-value pairs):
	croak('pdl_$func_name expects optional parameters ans key => value pairs')
		unless \@_ % 2 == 0;
	
	my \%args = \@_;
	
	# Get the a full list of arguments suitable for the internal pp code
	# in the correct order:
	my \@args_with_defs
		= get_sorted_args_with_defaults(\$self, \\$props_array_name, \\\%args);

	# Call the PP'd internal code. Always put the args hash last.
	eval {
		PDL::_prima_${func_name}_int(";
	# include all the required arguments:
	foreach(@arg_names) {
		$to_return .= '$' . $_ . ', ';
	}
	# finish with self and the args list:
	$to_return .= '@args_with_defs, \%args);
	};
	
	if ($@) {
		# die $@;
		$@ =~ s/at (.*?) line \d+\.\n$//;
		croak "Issues calling pdl_' . $func_name . ': $@";
	}
	' . "\n}\n";
	 
	return $to_return;
}


#######################################################################
#                              Functions                              #
#######################################################################

=begin details

At last I begin the declaration of PP code. The idea behind all of this
machinary is that I declare a collection of applicable properties in
THIS SCRIPT, and then use that to generate consistent code blocks. I
even use the properties array to generate compile-time accurate
documentation, so the on-machine documentation can never go out-of-sync
with the on-machine library.

=end details

=cut

##############
# prima_arcs #
##############

my @properties = qw(colors backColors lineEnds linePatterns lineWidths rops rop2s translates);
pp_def('prima_arcs',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('arcs', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for arcs, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_arc(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_arcs

=for sig

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                     start_angle(); end_angle(); properties)

=for ref

Draws arcs, i.e. incomplete ellipses.

The arcs go from the C<start_angle>s to the C<end_angle>s along the
ellipses centered at the C<x>s and C<y>s, with the specified x- and
y-diameters. The angles are measured in degrees, not radians.
The difference between this command and L</chords> or L</sectors> is that
C<arcs> does not connect the dangling ends.

Here's a simple example:

=for example

 # Draw a bunch of random arcs on $canvas:
 my $N_arcs = 20;
 my ($x_max, $y_max) = $canvas->size;
 my $xs = zeroes($N_arcs)->random * $x_max;
 my $ys = $xs->random * $y_max;
 my $dxs = $xs->random * $x_max / 4;
 my $dys = $xs->random * $y_max / 4;
 my $th_starts = $xs->random * 360;
 my $th_stops = $xs->random * 360;
 
 # Now that we've generated the data, call the command:
 $canvas->pdl_arcs($xs, $ys, $dxs
                , $dys, $th_starts, $th_stops);

If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of arcs will get
redrawn whenever you resize your window.


Compare to the Prima method L<Prima::Drawable/arc>. Closely related
routines include L</pdl_chords> and L</pdl_sectors>. See also
L</pdl_fill_chords>, and L</pdl_fill_sectors>, L</pdl_ellipses>, and
L</pdl_fill_ellipses>.

Spline drawing provides a similar functionality, though more complex and
more powerful. There are no PDL bindings for the spline functions yet.
See L<Prima::Drawable/spline> for more information.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

"

);

=pod

Applicable properties are likely to include handles, colors, backColors,
lineEnds, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

##############
# prima_bars #
##############

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_bars',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('bars', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's bar function */
			apc_gp_bar(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_bars

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws filled rectangle from corner (x1, y1) to (x2, y2).

=for example

 # Draw 20 random filled rectangles on $canvas:
 my $N_bars = 20;
 my ($x_max, $y_max) = $canvas->size;
 my $x1s = zeroes($N_bars)->random * $x_max;
 my $y1s = $x1s->random * $y_max;
 my $x2s = $x1s + $x1s->random * ($x_max - $x1s);
 my $y2s = $y1s + $x1s->random * ($y_max - $y1s);
 my $colors = $x1s->random * 2**24;
 
 # Now that we've generated the data, call the command:
 $canvas->pdl_bars($x1s, $y1s, $x2s, $y2s
         , colors => $colors);

If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of filled rectangles
will get redrawn whenever you resize your window.

Compare to the Prima method L<Prima::Drawable/bar>. See also
L</pdl_rectangles>, which is the unfilled equivalent, and L</pdl_clears>,
which is sorta the opposite of this.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut


################
# prima_chords #
################
@properties = qw(colors backColors clipRects lineEnds linePatterns lineWidths rops rop2s translates);
pp_def('prima_chords',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('chords', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for chords, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's chord function */
			apc_gp_chord(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_chords

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                           start_angle(); end_angle(); properties)

=for ref

Draws arcs (i.e. incomplete ellipses) whose ends are connected by a line.

The chord starts at C<start_angle> and runs to C<end_angle> along the ellipse
centered at C<x>, C<y>, with their specified diameters C<x_diameter>,
C<y_diameter>. Unlike L</arcs> or L</sectors>, it connects
the ends of the arc with a straight line. The angles are
measured in degrees, not radians.

=for example

 # For this example, you will need:
 use PDL::Char;
 
 # Draw a bunch of random arcs on $canvas:
 my $N_chords = 20;
 my ($x_max, $y_max) = $canvas->size;
 my $xs = zeroes($N_chords)->random * $x_max;
 my $ys = $xs->random * $y_max;
 my $dxs = $xs->random * $x_max / 4;
 my $dys = $xs->random * $y_max / 4;
 my $th_starts = $xs->random * 360;
 my $th_stops = $xs->random * 360;
 
 # make a small list of patterns:
 my $patterns_list = PDL::Char->new(
          [lp::Solid, lp::Dash, lp::DashDot]);
 
 # Randomly select 20 of those patterns:
 my $rand_selections = ($xs->random * 3)->byte;
 use PDL::NiceSlice;
 my $patterns = $patterns_list($rand_selections)->transpose;
 
 # Now that we've generated the data, call the command:
 $canvas->pdl_chords($xs, $ys, $dxs
                , $dys, $th_starts, $th_stops
                , linePatterns => $patterns);

If you put that snippet of code in the onPaint method, as
suggested in the synopsis, a completely new set of chords
will get redrawn whenever you resize your window.

Compare to the Prima method L<Prima::Drawable/chord>. The filled
equivalent is L</pdl_fill_chords>. Closely related routines are
L</pdl_arcs> and L</pdl_sectors>. See also L</pdl_fill_sectors>,
L</pdl_ellipses>, and L</pdl_fill_ellipses>, as well as
L<Prima::Drawable/spline>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

################
# prima_clears #
################

@properties = qw(backColors rop2s translates);
pp_def('prima_clears',
	Pars => 'int x1(); int y1(); int x2(); int y2();'
			. generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('clears', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for clears, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's clear function */
			apc_gp_clear(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_clears

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Clears the specified rectangle(s).

=for example

 my ($width, $height) = $canvas->size;
 # Begin by drawing a filled rectangle:
 $canvas->color(cl::Blue);
 $canvas->bar(0, 0, $width, $height);
 
 # Now cut random rectangles out of it:
 my $N_chunks = 20;
 my $x1 = random($N_chunks) * $width;
 my $x2 = random($N_chunks) * $width;
 my $y1 = random($N_chunks) * $width;
 my $y2 = random($N_chunks) * $width;
 $canvas->pdl_clears($x1, $y1, $x2, $y2);

Like the other examples, this will give you something new whenever you
resize the window if you put the code in the onPaint method, as the
Synopsis suggests.

Compare to the Prima method L<Prima::Drawable/clear>. In practice I
suppose this might be considered the opposite of L</pdl_bars>, though
technically this is meant for erasing, not drawing.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, backColors, rop2s,
and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

####################
# prima_draw_texts #
####################

# Not implemented

##################
# prima_ellipses #
##################

@properties = qw(colors backColors clipRects linePatterns lineWidths rops rop2s translates);
pp_def('prima_ellipses',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();'
			. generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('ellipses', \@properties, qw(x y x_diameter y_diameter)),
	Code => 
	# I don't need any extra variables for ellipses, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's ellipse function */
			apc_gp_ellipse(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter());
		%}
	],
	Doc => q{

=head2 pdl_ellipses

  Prima Signature: (widget; x(); y(); x_diameter();
                          y_diameter(); properties)

=for ref

Draws an ellipse centered at C<x>, C<y> with diameters C<x_diameter> and
C<y_diameter>. To draw circles, just use the same x- and y-diameter.

=for example

 working here

Compare to the Prima method L<Prima::Drawable/ellipse>. The filled
equivalent is L</pdl_fill_ellipses>. See also L</pdl_arcs>, L</pdl_chords>,
and L</pdl_sectors> as well as L</pdl_fill_chords> and
L</pdl_fill_sectors>. You may also be interested in L<Prima::Drawable/spline>,
which does not yet have a PDL interface.

=cut



}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#####################
# prima_fill_chords #
#####################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_fill_chords',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('fill_chords', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for chords, filled or otherwise,
	# so I'll just add the auto-generated declaration and initialization
	# code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's fill_chord function */
			apc_gp_fill_chord(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_fill_chords

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                          start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters. The ends
are connected with a line and the interior is filled. Use this to draw
the open-mouth part of a smiley face.

=for example

 # working here:
 $canvas->pdl_fill_chords($x, $y, $xd, $yd, $ti, $tf);

Compare to the Prima method L<Prima::Drawable/fill_chord>. The unfilled
equivalent is L</pdl_chords>. Closely related to L</pdl_fill_ellipses>
and L</pdl_fill_sectors>. See also L</pdl_arcs>, L</pdl_ellipses>,
and L</pdl_sectors>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#######################
# prima_fill_ellipses #
#######################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_fill_ellipses',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('fill_ellipses', \@properties, qw(x y x_diameter y_diameter)),
	Code => 
	# I don't need any extra variables for ellipses, filled or otherwise,
	# so I'll just add the auto-generated declaration and initialization
	# code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's fill_ellipse function */
			apc_gp_fill_ellipse(widget_handle, $x(), $y(), $x_diameter(), $y_diameter());
		%}
	],
	Doc => q{

=head2 pdl_fill_ellipses

  Prima Signature: (widget; x(); y(); x_diameter();
                          y_diameter(); properties)

=for ref

Draws a filled ellipse centered at C<x>, C<y>, with diameters
C<x_diameter> and C<y_diameter>. To draw filled circles, use the same
value for both diameters.

=for example

 # working here
 $canvas->pdl_fill_ellipses($x, $y, $xd, $yd);

Compare to the Prima method L<Prima::Drawable/fill_ellipse>. The unfilled
equivalent is L</pdl_ellipses>. Closely related to L</pdl_fill_chords> and
L</pdl_fill_ellipses>, and L</pdl_fill_sectors>.
See also L</pdl_arcs>, L</pdl_ellipses>, and L</pdl_sectors>. Also,
check out L<Prima::Drawable/fill_spline>, which does not yet have
PDL bindings.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

####################
# prima_fillpolys #
####################
@properties = qw(colors backColors clipRects fillPatterns fillWindings rops rop2s translates);
pp_def('prima_fillpolys',
	Pars => 'x(n); y(n); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('fillpolys', \@properties, qw(x y)),
	Code => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs gracefully, and I am simply skipping over
			 * nan values, treating them just as I would bad values.
			 * Note that polylines draws a gap at bad values, but here
			 * I simply skip over them.
			 */
			n_to_plot = 0;
			for(i = 0; i < n_size; i++) {
				xval = $x(n => i);
				yval = $y(n => i);

				/* Move to the next value if we encounter nan */
				if (xval != xval || yval != yval) {		/* nan check */
					continue;
				}

				/* handle infinities */
				if (xval == xval + 1) {
					if (xval < 0)
						xval = -MY_BIG_NUMBER;
					else
						xval = MY_BIG_NUMBER;
				}
				if (yval == yval + 1) {
					if (yval < 0)
						yval = -MY_BIG_NUMBER;
					else
						yval = MY_BIG_NUMBER;
				}
				/* Handle very large values */
				if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
				if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
				if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
				if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
				
				to_plot[n_to_plot].x = xval;
				to_plot[n_to_plot].y = yval;

				/* Keep track of the number of points added */
				n_to_plot++;
			}
			/* Call apricot's fillpoly function */
			if (n_to_plot > 2)
				apc_gp_fill_poly(widget_handle, n_to_plot, to_plot);
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	HandleBad => 1,
	BadCode => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs gracefully, and I am simply skipping over
			 * nan values and BAD values.
			 * Note that polylines draws a gap at bad values, but here
			 * I simply skip over them.
			 */
			n_to_plot = 0;
			for(i = 0; i < n_size; i++) {
				xval = $x(n => i);
				yval = $y(n => i);

				/* Move to the next value if we encounter something bad */
				if (xval != xval || yval != yval	/* nan check */
					|| $ISBAD(x(n => i))			/* bad value */
					|| $ISBAD(y(n => i))) {			/* checks    */
					continue;
				}

				/* handle infinities */
				if (xval == xval + 1) {
					if (xval < 0)
						xval = -MY_BIG_NUMBER;
					else
						xval = MY_BIG_NUMBER;
				}
				if (yval == yval + 1) {
					if (yval < 0)
						yval = -MY_BIG_NUMBER;
					else
						yval = MY_BIG_NUMBER;
				}
				/* Handle very large values */
				if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
				if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
				if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
				if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
				
				to_plot[n_to_plot].x = xval;
				to_plot[n_to_plot].y = yval;

				/* Keep track of the number of points added */
				n_to_plot++;
			}
			/* Call apricot's fillpoly function */
			if (n_to_plot > 2)
				apc_gp_fill_poly(widget_handle, n_to_plot, to_plot);
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	Doc => q{

=head2 pdl_fillpolys

  Prima Signature: (widget; x(n); y(n); properties)

=for ref

Draws and fills a polygon with arbitrary edge vertices.

NOTE: there is B<no> underscore between C<fill> and C<poly>, which is
different from the other C<fill> methods!

This is most useful for drawing line drawing of crystals and rocks, and
for visualizing integrals. Splines would be the better choice if you
want to draw curves, but a PDL interface to splines is not (yet)
implemented.

Unlike most of the other methods, this one actually makes an effort to
process bad values. In addition to the IEEE bad values of C<nan> and
C<inf>, PDL has support for bad values. All of these should be handled
reasonably well by C<pdl_fillpolys>. If you give it 

Because this skips bad data altogether, if you have too much bad data
(i.e. fewer than three good points), the routine will simply not draw
anything. I'm debating if this should croak, or at least give a warning.
(Of course, a warning to STDOUT is rather silly for a GUI toolkit.)

For example:

=for example

 # working here
 $canvas->pdl_fillpolys($x, $y);

Compare to the Prima method L<Prima::Drawable/fillpoly>. See also
L</pdl_bars> and L<pdl_polylines>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns, fillWindings,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

######################
# prima_fill_sectors #
######################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_fill_sectors',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('fill_sectors', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for filled sectors, so I'll just
	# add the auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_fill_sector(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_fill_sectors

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter();
                          start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, with specified x- and y-diameters. Like
L</fill_chords>, this command connects the end points of the arc, but
unlike L</fill_chords>, it does so by drawing two lines, both of which
also connect to the ellipse's center. This results in shapes that look
like pie pieces.

=for example

 # working here
 $canvas->pdl_fill_sectors($x, $y, $xd, $yd, $th1, $th2);

Compare to the Prima method L<Prima::Drawable/fill_sector>. The unfilled
equivalent is L</pdl_sectors>. This is closely related to C</pdl_fill_chords>
and C</pdl_fill_ellipses>. See also L</pdl_arcs>, L</pdl_chords>, and
L</pdl_ellipses>.

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

######################
# prima_fill_splines #
######################

# Not implemented

#####################
# prima_flood_fills #
#####################

@properties = qw(colors backColors clipRects fillPatterns rops rop2s translates);
pp_def('prima_flood_fills',
	Pars => 'int x(); int y(); int color(); int singleborder(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('flood_fills', \@properties, qw(x y color singleborder)),
	Code => 
	# I don't need any extra variables for flood fills, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's flood fill function */
			apc_gp_flood_fill(widget_handle, $x(), $y(), (Color)$color(), $singleborder());
		%}
	],
	Doc => q{

=head2 pdl_flood_fills

  Prima Signature: (widget; x(); y(); color();
                   singleborder(); properties)

=for ref

# working here:

Fills an area of the canvas...

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
fillPatterns,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

###############
# prima_lines #
###############

@properties = qw(colors backColors clipRects lineEnds lineJoins linePatterns lineWidths rops rop2s translates);
pp_def('prima_lines',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('lines', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's lines function */
			apc_gp_line(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	BadCode => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
			/* Skip any points that are bad */
			if ( $ISBAD(x1()) || $ISBAD(y1()) || $ISBAD(x2()) || $ISBAD(y2()) ) {
				continue;
			}
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's lines function */
			apc_gp_line(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	HandleBad => 1,
	Doc => q{

=head2 pdl_lines

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws a line from (x1, y1) to (x2, y2).

In contrast to polylines, which are supposed to be connected, these
lines are meant to be independent.

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, lineJoins, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

################
# prima_pixels #
################

@properties = qw(colors clipRects translates);
pp_def('prima_pixels',
	Pars => 'int x(); int y(); int [o] color(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('pixels', \@properties, qw(x y color)),
	Code => 
	# I don't need any extra variables for pixels, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q{
		threadloop %{
			/* Unlike usual, I will not use the setter code. Rather,
			 * the is_setting_colors will determine whether or not I
			 * set the pixel:
			 *
			 * working here: no initialize_for(@properties)?
			 */
			if (is_setting_colors) {
				apc_gp_set_pixel(widget_handle, $x(), $y(), (Color)$colors());
			}
			
			/* No matter what, get the previous color. NOTE that the
			 * retrieved results goes in color (singular), not colors
			 */
			$color() = (PDL_Long) apc_gp_get_pixel(widget_handle, $x(), $y());
		%}
	},
	BadCode =>
	# I don't need any extra variables for pixels, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q{
		threadloop %{
			/* Unlike usual, I will not use the setter code. Rather,
			 * the is_setting_colors, and the good state for everything, is
			 * will determine whether or not I set the pixel:
			 */
			if (is_setting_colors && $ISGOOD(x()) && $ISGOOD(y())
					&& $ISGOOD(colors())) {
				apc_gp_set_pixel(widget_handle, $x(), $y(), (Color)$colors());
			}
			
			/* No matter what, get the previous color. NOTE that the
			 * retrieved results goes in color (singular), not colors
			 */
			$color() = (PDL_Long) apc_gp_get_pixel(widget_handle, $x(), $y());
		%}
	},
	HandleBad => 1,
	Doc => q{

=head2 pdl_pixels

  Prima Signature: (widget; x(); y(); properties)

=for ref

Sets the pixel at (x, y) to the current color, or to the value(s) passed
in the C<color> property.

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, clipRects, and
translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

###################
# prima_polylines #
###################

@properties = qw(colors backColors clipRects lineEnds lineJoins linePatterns
					lineWidths rops rop2s translates);
pp_def('prima_polylines',
	Pars => 'x(n); y(n); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('polylines', \@properties, qw(x y)),
	Code => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
		/* Need these to do reasonable cutting-out of data outside the
		 * plotting window
		 */
		int x_min, x_max, y_min, y_max;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs and nans gracefully by treating the same
			 * way as I would bad values.
			 */
			for(i = 0; i < n_size; /* no action */) {
				for(n_to_plot = 0; n_to_plot + i < n_size; n_to_plot++) {
					int total_offset = n_to_plot + i;
					xval = $x(n => total_offset);
					yval = $y(n => total_offset);
					
					/* Finish this segment if we encounte nan */
					if (xval != xval || yval != yval) {		/* nan check */
						/* increment i so that it skips this value on
						 * the next round
						 */
						i++;
						break;
					}
					
					/* handle infinities */
					if (xval == xval + 1) {
						if (xval < 0)
							xval = -MY_BIG_NUMBER;
						else
							xval = MY_BIG_NUMBER;
					}
					if (yval == yval + 1) {
						if (yval < 0)
							yval = -MY_BIG_NUMBER;
						else
							yval = MY_BIG_NUMBER;
					}
					
					/* Handle very large values */
					if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
					if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
					if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
					if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
					
					to_plot[n_to_plot].x = xval;
					to_plot[n_to_plot].y = yval;
				}
				/* Call apricot's polyline function */
				if (n_to_plot > 1) {
					printf("Calling apricot's function\n");
					apc_gp_draw_poly(widget_handle, n_to_plot, to_plot);
				}
				
				/* Keep track of the starting position */
				i += n_to_plot;
			}
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	HandleBad => 1,
	BadCode => 
	# Begin by declaring the non-autogenerated the variables I will need
	q{
		Point * to_plot;
		int n_size, i, n_to_plot;
		double xval, yval;
	}
	# Add the auto-generated declaration and initialization code:
	. initialize_for(@properties)
	# Continue with my initialization code and the threadloop:
	. q[
		/* Allocate an array of Points outside of the threadloop */
		n_size = $SIZE(n);
		Newx(to_plot, n_size, Point);
		
		/* All set. Start the threadloop with the setters. */
		threadloop %{
		]
		. generate_setter_code_for(@properties)
		. q[
			/* Put the x-y data into the to_plot array. I am attempting
			 * to handle infs and nans gracefully by treating the same
			 * way as I would bad values.
			 */
			for(i = 0; i < n_size; /* no action */) {
				for(n_to_plot = 0; n_to_plot + i < n_size; n_to_plot++) {
					/* Get the values from the array */
					int total_offset = n_to_plot + i;
					xval = $x(n => total_offset);
					yval = $y(n => total_offset);
					
					/* finish this segment if we encounter nan or a bad value */
					if (xval != xval || yval != yval			/* nan check */
						|| $ISBAD(x(n => total_offset))		/* bad value */
						|| $ISBAD(y(n => total_offset))) {	/* checks    */
						/* increment i so that it skips this value on
						 * the next round
						 */
						i++;
						break;
					}
					else {
						/* handle infinities */
						if (xval == xval + 1) {
							if (xval < 0)
								xval = -MY_BIG_NUMBER;
							else
								xval = MY_BIG_NUMBER;
						}
						if (yval == yval + 1) {
							if (yval < 0)
								yval = -MY_BIG_NUMBER;
							else
								yval = MY_BIG_NUMBER;
						}
						/* Handle very large values */
						if (yval > MY_BIG_NUMBER) yval = MY_BIG_NUMBER;
						if (xval > MY_BIG_NUMBER) xval = MY_BIG_NUMBER;
						if (yval < -MY_BIG_NUMBER) yval = -MY_BIG_NUMBER;
						if (xval < -MY_BIG_NUMBER) xval = -MY_BIG_NUMBER;
						
						to_plot[n_to_plot].x = xval;
						to_plot[n_to_plot].y = yval;
					}
				}
				/* Call apricot's polyline function */
				if (n_to_plot > 1)
					apc_gp_draw_poly(widget_handle, n_to_plot, to_plot);
				
				/* Keep track of the starting position */
				i += n_to_plot;
			}
		%}
		
		/* Free the memory when done */
		Safefree(to_plot);
	],
	Doc => q{

=head2 pdl_polylines

  Prima Signature: (widget; x(n); y(n); properties)

=for ref

Draws a multi-segment line on a widget with the given x- and y-coordinates.

This is useful for making line-drawings, such as plotting data.

=for example

 # Draw a sine curve on the widget:
 my $x = sequence(200);
 my $y = ( sin($x / 20) + 1 ) * 50;
 $canvas->pdl_polylines($x, $y);

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, lineJoins, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.
				color, backColor, linePattern, lineWidth, lineJoin, lineEnd, rop, rop2

=cut

####################
# prima_put_images #
####################

# Not implemented

#############################
# prima_put_images_indirect #
#############################

# Not implemented

#################
# prima_rects3d #
#################

# Not implemented

###################
# prima_rect_foci #
###################

# Not implemented

####################
# prima_rectangles #
####################

@properties = qw(colors backColors clipRects linePatterns lineWidths rops rop2s translates);
pp_def('prima_rectangles',
	Pars => 'int x1(); int y1(); int x2(); int y2(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['L'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('rectangles', \@properties, qw(x1 y1 x2 y2)),
	Code => 
	# I don't need any extra variables for bars, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's rectangle function */
			apc_gp_rectangle(widget_handle, $x1(), $y1(), $x2(), $y2());
		%}
	],
	Doc => q{

=head2 pdl_rectangles

  Prima Signature: (widget; x1(); y1(); x2(); y2(); properties)

=for ref

Draws a rectangle from corner (x1, y1) to (x2, y2).

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#################
# prima_sectors #
#################

@properties = qw(colors backColors clipRects lineEnds linePatterns lineWidths rops rop2s translates);
pp_def('prima_sectors',
	Pars => 'int x(); int y(); int x_diameter(); int y_diameter();
			start_angle(); end_angle(); ' . generate_pars_args_for(@properties),
	OtherPars => $default_other_pars,
	GenericTypes => ['D'],
	PMFunc => undef,
	NoPthread => 1,
	PMCode => generate_PMCode_for('sectors', \@properties, qw(x y x_diameter y_diameter start_angle end_angle)),
	Code => 
	# I don't need any extra variables for sectors, so I'll just add the
	# auto-generated declaration and initialization code:
	  initialize_for(@properties)
	# Continue with the threadloop:
	. q[
		threadloop %{
		]
		# Now comes the code that calls the various setters for the various
		# properties:
		. generate_setter_code_for(@properties)
		. q[
			/* Call apricot's arc function */
			apc_gp_sector(widget_handle, $x(), $y(), $x_diameter(),
				$y_diameter(), $start_angle(), $end_angle());
		%}
	],
	Doc => q{

=head2 pdl_sectors

  Prima Signature: (widget; x(); y(); x_diameter(); y_diameter(); start_angle(); end_angle(); properties)

=for ref

Draws an arc from C<start_angle> to C<end_angle> along the ellipse
centered at C<x>, C<y>, each with their specified diameters. The
difference between this command and L<chords> is that this command does
not connect the ends of the arcs with straight lines but leaves the
arcs open

=for example

 working here

=cut

}. "=pod\n\nApplicable properties include " . join(', ', 'handles', @properties) . "
\n=cut

");

=pod

Applicable properties are likely to include handles, colors, backColors, clipRects,
lineEnds, linePatterns, lineWidths,
rops, rop2s, and translates. However, this list could be
out of date or out of order. If you've installed this module on your own
machine, the documentation is guaranteed to describe the applicable
properties, in their correct order.

=cut

#################
# prima_splines #
#################

# Not implemented

########################
# prima_stretch_images #
########################

# Not implemented

###################
# prima_texts_out #
###################

# Not implemented

#######################################################
# Additional Functions that do Not Need the Machinery #
#######################################################

#################
# minmaxforpair #
#################

=head2 minmaxforpair

=cut

pp_def('minmaxforpair',
	Pars => 'x(n); y(n); [o] min_x(); [o] min_y(); [o] max_x(); [o] max_y()',
	# Good code.
	Code => q{
		// Set the initial values for the min/max. Since I know that these will
		// be good, I can assume that the first value is a good starting guess.
		$min_x() = $x(n => 0);
		$max_x() = $x(n => 0);
		$min_y() = $y(n => 0);
		$max_y() = $y(n => 0);
		
		loop(n) %{
			if ($x() < $min_x()) $min_x() = $x();
			if ($max_x() < $x()) $max_x() = $x();
			if ($y() < $min_y()) $min_y() = $y();
			if ($max_y() < $y()) $max_y() = $y();
		%}
	},
	# Bad code
	HandleBad => 1,
	BadCode => q{
		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		$SETBAD(min_x());
		$SETBAD(max_x());
		$SETBAD(min_y());
		$SETBAD(max_y());
		
		loop(n) %{
			// Only check (and possibly change) if both x and y are good:
			if ($ISGOOD(x()) && $ISGOOD(y())) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ($ISBAD(min_x())) {
					$min_x() = $x();
					$max_x() = $x();
					$min_y() = $y();
					$max_y() = $y();
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ($x() < $min_x()) $min_x() = $x();
					if ($max_x() < $x()) $max_x() = $x();
					if ($y() < $min_y()) $min_y() = $y();
					if ($max_y() < $y()) $max_y() = $y();
				}
			}
		%}
	},
	Doc => q{

=pod

=for ref

Returns the min/max values for the pairs of coordinates x and y.

This function is only really useful in one very specific context: when the
number of dimensions for x and y do not agree, and when you have bad data in
x, y, or both.

Suppose that you know that x and y are good. Then you could get the min/max
data using the C<minmax> function:

 my ($xmin, $xmax) = $x->minmax;
 my ($ymin, $ymax) = $y->minmax;

On the other hand, if you have data but you know that the dimensions of x and
y match, you could modify the above like so:

 my ($xmin, $xmax) = $x->where($x->isgood & $y->isgood)->minmax;
 my ($ymin, $ymax) = $y->where($x->isgood & $y->isgood)->minmax;

However, what if you have only one-dimensional x-data but two-dimensional
y-data? For example, you want to plot mutliple y datasets against the same
x-coordinates. In that case, if some of the x-data is bad, you could probably
hack something, but if some of the y-data is bad you you will have a hard time
picking out the good pairs, and getting the min/max from them. That is the
purpose of this function.

=cut

	},
	BadDoc => q{

=pod

Output is set bad if no pair of x/y data is good.

=cut

	},
);

#################
# colors_to_rgb #
#################
# Based on value2rgb from Prima's ColorDialog.pm

=color_to_rgb

=cut

pp_def('color_to_rgb',
	Pars => 'int color(); int [o] rgb(n=3)',
	Code => q{
		$rgb(n=>0) = $color() >> 16 & 0xFF;
		$rgb(n=>1) = $color() >> 8 & 0xFF;
		$rgb(n=>2) = $color() & 0xFF;
	},
	HandleBad => 1,
	BadCode => q{
		if ($ISBAD(color())) {
			loop(n) %{
				$SETBAD(rgb());
			%}
		}
		else {
			$rgb(n=>0) = $color() >> 16 & 0xFF;
			$rgb(n=>1) = $color() >> 8 & 0xFF;
			$rgb(n=>2) = $color() & 0xFF;
		}
	},
	Doc => <<DOCUMENTATION,

=pod

=for ref

Converts a Prima color value to RGB representation

If the input piddle has dimension (m, n, ...), the output piddle has
dimensions (3, m, n, ...). The first element represents the red value, the
second the green value, and the third the blue value. The resulting piddle is
suitable for use in C<rgb_to_colors> or C<rgb_to_hsv>.

The code for this routine is based on C<value2rgb> from L<Prima::colorDialog>.

=cut

DOCUMENTATION
	BadDoc => <<BADDOC

=for bad

If C<color_to_rgb> encounters a bad value in the input, the output piddle will
be marked as bad and the associated rgb values will all be marked with the bad
value.

=cut

BADDOC
);

#################
# rgb_to_colors #
#################
# Based on rgb2value from Prima's ColorDialog.pm

=head2 rgb_to_color

=cut

pp_def('rgb_to_color',
	Pars => 'int rgb(n=3); int [o] color()',
	Code => q{
		int r, g, b;
		threadloop %{
			/* extract and clean up the rgb values */
			r = $rgb(n => 0);
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = $rgb(n => 1);
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = $rgb(n => 2);
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			$color() = b | g<<8 | r<<16;
		%}
	},
	HandleBad => 1,
	BadCode => q{
		int r, g, b;
		threadloop %{
			if ($ISBAD(rgb(n=>0)) || $ISBAD(rgb(n=>1)) || $ISBAD(rgb(n=>2))) {
				$SETBAD(color());
			}
			else {
				/* extract and clean up the rgb values */
				r = $rgb(n => 0);
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = $rgb(n => 1);
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = $rgb(n => 2);
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				$color() = b | g<<8 | r<<16;
			}
		%}
	},
	Doc => <<DOCUMENTATION,

=pod

=for ref

Converts an RGB color to a Prima color value

Red, green, and blue values must fall between 0 and 255. Any values outside
those boundaries will be truncated to the nearest boundary before computing the
color.

The RGB values must be in the first dimension. In other words, the size of the
first dimension must be three, so if the input piddle has dimensions (3, m, n,
...), the output piddle will have dimension (m, n, ...). The resulting piddle is
suitable for use when specifying colors to drawing primitives.

The code for this routine is based on C<rgb2value> from L<Prima::colorDialog>.

=cut

DOCUMENTATION
	BadDoc => <<BADDOC,

=for bad

If C<rgb_to_color> encounters a bad value in any of the red, green, or blue
values of the input, the output piddle will be marked as bad and the associated
color values will all be marked as bad.

=cut

BADDOC
);

##############
# hsv_to_rgb #
##############
# Based on hsv2rgb from Prima's ColorDialog.pm

=head2 hsv_to_rgb

=cut

my $hsv_to_rgb_code = q{
			/* Get and adjust the value */
			v = $hsv(n=>2);
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = $hsv(n=>1);
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				$rgb(m=>0) = v;
				$rgb(m=>1) = v;
				$rgb(m=>2) = v;
				continue;
			}
			
			/* Get and adjust the hue */
			h = $hsv(n=>0);
			if (h < 0) h = 0;
			if (h > 360) h = 360;
			
			/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
			h /= 60;
			
			/* To help understand this, see */
			/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
			i = (int) h;
			f = h - i;
			w = v * (1 - s);
			q = v * (1 - (s * f));
			t = v * (1 - (s * (1 - f)));
			
			if (i == 0) {
				$rgb(m=>0) = v;
				$rgb(m=>1) = t;
				$rgb(m=>2) = w;
			}
			else if (i == 1) {
				$rgb(m=>0) = q;
				$rgb(m=>1) = v;
				$rgb(m=>2) = w;
			}
			else if (i == 2) {
				$rgb(m=>0) = w;
				$rgb(m=>1) = v;
				$rgb(m=>2) = t;
			}
			else if (i == 3) {
				$rgb(m=>0) = w;
				$rgb(m=>1) = q;
				$rgb(m=>2) = v;
			}
			else if (i == 4) {
				$rgb(m=>0) = t;
				$rgb(m=>1) = w;
				$rgb(m=>2) = v;
			}
			else {
				$rgb(m=>0) = v;
				$rgb(m=>1) = w;
				$rgb(m=>2) = q;
			}
};

pp_def('hsv_to_rgb',
	Pars => 'float+ hsv(n=3); int [o]rgb(m=3)',
	Code => q[
		$GENERIC(hsv) v, s, h, f, w, q, t;
		int i;
		
		threadloop %{
			] . $hsv_to_rgb_code . q[
		%}
	],
	HandleBad => 1,
	BadCode => q[
		$GENERIC(hsv) v, s, h, f, w, q, t;
		int i;
		
		threadloop %{
			/* First check for bad values */
			if ($ISBAD(hsv(n=>0)) || $ISBAD(hsv(n=>1)) || $ISBAD(hsv(n=>2))) {
				loop (m) %{
					$SETBAD(rgb());
				%}
				/* skip to the next hsv triple */
				continue;
			}
			] . $hsv_to_rgb_code . q[
		%}
	],
	Doc => <<DOCUMENTATION,

=pod

=for ref

Converts an HSV color triple to an RGB color triple

HSV stands for hue-saturation-value and is nicely represented by a cirle in a
color palette. In this representation, the numbers representing saturation and
value must be between 0 and 1; anything less than zero or greater than 1 will be
truncated to the closest limit. The hue must be a value between 0 and 360, and
again it will be truncated to the corresponding limit if that is not the case.
For more information about HSV, see L<http://en.wikipedia.org/wiki/HSL_and_HSV>.

Note that Prima's C<hsv2rgb> function, upon which this was based, had a special
notation for a hue of -1, which always corresponded to a saturation of 0. Since
a saturation of 0 means 'use greyscale', this function does not make any special
use of that notation.

The first dimension of the piddles holding the hsv and rgb values must be size
3, i.e. the dimensions must look like (3, m, n, ...). The resulting piddle is
suitable for input into L<rgb_to_color> as well as manual manipulation.

The code for this routine is based on C<hsv2rgb> from L<Prima::colorDialog>.

=cut

DOCUMENTATION
	BadDoc => <<BADDOC,

=for bad

If C<hsv_to_rgb> encounters a bad value in any of the hue, saturation, or value
quantities, the output piddle will be marked as bad and the associated rgb
color values will all be marked as bad.

=cut

BADDOC
);

##############
# rgb_to_hsv #
##############
# Based on rgb2hsv from Prima's ColorDialog.pm

=head2 rgb_to_hsv

=cut

#	if ( $r == $max) {
#		$h = ( $g - $b) / $delta;
#	} elsif ( $g == $max) {
#		$h = 2 + ( $b - $r) / $delta;
#	} else {
#		$h = 4 + ( $r - $g) / $delta;
#	}
#	$h *= 60;
#	$h += 360 if $h < 0;
#	return $h, $s, $v;


my $rgb_to_hsv_code = q{
			/* Get and rescale the rgb values */
			r = $rgb(n=>0);
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = $rgb(n=>1);
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = $rgb(n=>2);
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				$hsv(m=>0) = 0;
				$hsv(m=>1) = 0;
				$hsv(m=>2) = v;
				continue;
			}
			s = delta / max;
			
			/* compute hue */
			if (r == max) {
				h = (g - b) / delta;
			}
			else if (g == max) {
				h = 2 + (b - r) / delta;
			}
			else {
				h = 4 + (r - g) / delta;
			}
			h *= 60;
			if (h < 0) h += 360;
			
			$hsv(m=>0) = h;
			$hsv(m=>1) = s;
			$hsv(m=>2) = v;
};

pp_def('rgb_to_hsv',
	Pars => 'int rgb(n=3); float+ [o]hsv(m=3)',
	Code => q[
		$GENERIC(hsv) r, g, b, h, s, v, max, min, delta;
		
		threadloop %{
			] . $rgb_to_hsv_code . q[
		%}
	],
	HandleBad => 1,
	BadCode => q[
		$GENERIC(hsv) r, g, b, h, s, v, max, min, delta;
		
		threadloop %{
			/* First check for bad values */
			if ($ISBAD(rgb(n=>0)) || $ISBAD(rgb(n=>1)) || $ISBAD(rgb(n=>2))) {
				loop (m) %{
					$SETBAD(hsv());
				%}
				/* skip to the next hsv triple */
				continue;
			}
			] . $rgb_to_hsv_code . q[
		%}
	],
	Doc => <<DOCUMENTATION,

=pod

=for ref

Converts an RGB color triple to an HSV color triple

HSV stands for hue-saturation-value and is nicely represented by a cirle in a
color palette. In this representation, the numbers representing saturation and
value will run between 0 and 1. The hue will be a value between 0 and 360.
For more information about HSV, see L<http://en.wikipedia.org/wiki/HSL_and_HSV>.

Note that Prima's C<rgb2hsv> function, upon which this was based, returned a
special value if r == g == b. In that case, it returned a hue of -1 and a
saturation of zero. In the rgb color is a greyscale and the value is based
simply on that. This function does not make use of that special hue value; it
simply returns a hue value of 0.

The first dimension of the piddles holding the hsv and rgb values must be size
3, i.e. the dimensions must look like (3, m, n, ...). The resulting piddle is
suitable for manual manipulation and input into L<hsv_to_rgb>.

The code for this routine is based on C<rgb2hsv> from L<Prima::colorDialog>.

=cut

DOCUMENTATION
	BadDoc => <<BADDOC,

=for bad

If C<rgb_to_hsv> encounters a bad value in any of the red, green, or blue values
the output piddle will be marked as bad and the associated hsv values will all
be marked as bad.

=cut

BADDOC
);

pp_addpm({At=>'Bot'},<<'EOD');

=head1 ERROR MESSAGE

These functions may throw the following exception:

=head2 Your widget must be derived from Prima::Drawable

This means that you tried to draw on something that is not a Prima::Drawable
object, or a class derived from it. I don't know enough about the Prima
internals to know if that has any hope of working, but why do it in the first
place?

=head1 PDL::PP DETAILS

Those well versed in PDL::PP might ask how I manage to produce pdlified methods
that take variable numbers of arguments. That is a long story, and it is told in
the volumes of comments in pdlprima.pd. Give it a read if you want to know what
goes on behind the scenes.

=head1 TODO

These are all the things I wish to do:

=over

=item Full Drawabel API

I would like a PDL function for every drawable function in the API.
Prima Drawable functions that currently do not have an equivalent PDL
implementation include L<Prima::Drawable/draw_text>,
L<Prima::Drawable/fill_spline>, L<Prima::Drawable/put_image>,
L<Prima::Drawable/put_image_indirect>, L<Prima::Drawable/rect3d>,
L<Prima::Drawable/rect_focus>, L<Prima::Drawable/spline>,
L<Prima::Drawable/stretch_image>, and L<Prima::Drawable/text_out>

=item PS Functionality

Currently, this library only implements PDL functions using the apricot
library. Since L<Prima::PS::Drawable> implements its own drawing
functions, none of the PDL drawing functions will work with a PS drawable.
They need their own specially created functions that will emit postscript
code. It's not a hard problem, but it will take some time and work, and
it's likely that a seperate interface would be best.

=item Bad Value Support

PLplot's bindings have a very sensible interpretation for bad values:
they are omitted. This should be replicated in this library. It has been
implemented in L</polylines> and L</fillpolys>, but not for the other
functions.

=back

=head1 AUTHOR

David Mertens, E<lt>dcmertens.perl@gmail.comE<gt>.

=head1 SEE ALSO

This is built as an extension for the Prima toolkit, http://www.prima.eu.org/, L<Prima>.

This is built using (and targeted at users of) the Perl Data Language, L<PDL>.

This is the bedrock for the plotting package L<PDL::Graphics::Prima>.

Another interface between PDL and Prima is <PDL::PrimaImage>. I am indebted to
Dmitry for that module because it gave me a working template for this module,
including a working Makefile.PL. Thanks Dmitry!

=cut

EOD


pp_export_nothing();
pp_done();

#__END__

#############################
# Remove incorrect PDL docs #
#############################
# removes the stupid full-signature documentation.
# working here - this can be removed by properly handling the Doc key in the
# pp_def function call. When you supply an empty string, no documentation gets
# generated. That lets me to add my own pod in the PMCode section.

open my $in, '<', 'Prima.pm';
open my $out, '>', 'new_Prima.pm';

my $is_discarding = 0;
my $found_functions = 0;

LINE: while (<$in>) {
	if ($is_discarding) {
		# Discard the line unless we find our end marker:
		next LINE unless /=head2 pdl_/;
		$is_discarding = 0;
	}
	elsif (/=head2 prima_/) {
		# Check if we *should* start discarding:
		$is_discarding = 1;
		next LINE;
	}
	
	# Remove the spurious =head1 FUNCTIONS documentation
	if ($found_functions and /=head1 FUNCTIONS/) {
		# Eat everything up to the =cut
		while(<$in> !~ /=cut/) {}
		next LINE;
	}
	$found_functions++ if /=head1 FUNCTIONS/;
	
	s/(?<!_)prima_/pdl_/;
	
	print $out $_;
}

close $in;
close $out;
unlink 'Prima.pm';
rename 'new_Prima.pm' => 'Prima.pm';


