/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2210 from the
 * contents of Utils.xs. Do not edit this file, edit Utils.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/PDL/Drawing/Prima/Utils.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; /* Structure hold core C functions */
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       /* Gets pointer to perl var holding core structure */

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif

typedef struct pdl_color_to_rgb_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_rgb_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_color_to_rgb_struct;

void pdl_color_to_rgb_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_color_to_rgb_struct *__privtrans = (pdl_color_to_rgb_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = 3;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"color","rgb"};
		static int __realdims[] = {0,1};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::color_to_rgb";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in color_to_rgb:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_rgb_n = 0; else
		 __privtrans->__inc_rgb_n = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_color_to_rgb_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_color_to_rgb_struct *__privtrans = (pdl_color_to_rgb_struct *) __tr;
	
	{
	    pdl_color_to_rgb_struct *__copy = malloc(sizeof(pdl_color_to_rgb_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_rgb_n=__copy->__inc_rgb_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_color_to_rgb_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_color_to_rgb_struct *__privtrans = (pdl_color_to_rgb_struct *) __tr;
	
	{
	    {register int __n_size = __privtrans->__n_size;
/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_S: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_US: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_L: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_LL: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_F: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_D: {
	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		if ((color_datap)[0] /* ACCESS() */  == color_badval) {
			{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
				(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  = rgb_badval;
			}} /* Close n */
		}
		else {
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
			(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
		}
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];color_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 16 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  >> 8 & 0xFF;
		(rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  = (color_datap)[0] /* ACCESS() */  & 0xFF;
	
}	/* THREADLOOPEND */
	 color_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } color_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} color_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 color_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_color_to_rgb_free(pdl_trans *__tr ) {
	int __dim;
	pdl_color_to_rgb_struct *__privtrans = (pdl_color_to_rgb_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_color_to_rgb_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_color_to_rgb_vtable = {
		0,0, 1, 2, pdl_color_to_rgb_vtable_flags,
		pdl_color_to_rgb_redodims, pdl_color_to_rgb_readdata, NULL,
		pdl_color_to_rgb_free,NULL,NULL,pdl_color_to_rgb_copy,NULL,
		sizeof(pdl_color_to_rgb_struct),"pdl_color_to_rgb_vtable",
		NULL
	 };

typedef struct pdl_rgb_to_color_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_rgb_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_rgb_to_color_struct;

void pdl_rgb_to_color_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_color_struct *__privtrans = (pdl_rgb_to_color_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = 3;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"rgb","color"};
		static int __realdims[] = {1,0};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::rgb_to_color";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rgb_to_color:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_rgb_n = 0; else
		 __privtrans->__inc_rgb_n = PDL_REPRINC(__privtrans->pdls[0],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_rgb_to_color_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_color_struct *__privtrans = (pdl_rgb_to_color_struct *) __tr;
	
	{
	    pdl_rgb_to_color_struct *__copy = malloc(sizeof(pdl_rgb_to_color_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_rgb_n=__copy->__inc_rgb_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_rgb_to_color_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_color_struct *__privtrans = (pdl_rgb_to_color_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_S: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_US: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_L: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_LL: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_F: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_D: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * color_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * color_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   color_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				(color_datap)[0] /* ACCESS() */  = color_badval;
			}
			else {
				/* extract and clean up the rgb values */
				r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (r < 0) r = 0;
				if (r > 255) r = 255;
				g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
				if (g < 0) g = 0;
				if (g > 255) g = 255;
				b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
				if (b < 0) b = 0;
				if (b > 255) b = 255;
				
				/* compute and return the color value */
				(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		int r, g, b;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
color_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* extract and clean up the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			
			/* compute and return the color value */
			(color_datap)[0] /* ACCESS() */  = b | g<<8 | r<<16;
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
color_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
color_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;color_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
color_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_rgb_to_color_free(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_color_struct *__privtrans = (pdl_rgb_to_color_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_rgb_to_color_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_rgb_to_color_vtable = {
		0,0, 1, 2, pdl_rgb_to_color_vtable_flags,
		pdl_rgb_to_color_redodims, pdl_rgb_to_color_readdata, NULL,
		pdl_rgb_to_color_free,NULL,NULL,pdl_rgb_to_color_copy,NULL,
		sizeof(pdl_rgb_to_color_struct),"pdl_rgb_to_color_vtable",
		NULL
	 };

typedef struct pdl_hsv_to_rgb_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_hsv_n;PDL_Long  __inc_rgb_m;PDL_Long  __n_size;PDL_Long  __m_size;
		
		char __ddone; /* Dims done */
		} pdl_hsv_to_rgb_struct;

void pdl_hsv_to_rgb_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_hsv_to_rgb_struct *__privtrans = (pdl_hsv_to_rgb_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = 3;
__privtrans->__m_size = 3;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"hsv","rgb"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::hsv_to_rgb";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in hsv_to_rgb:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__m_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in hsv_to_rgb:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__m_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_hsv_n = 0; else
		 __privtrans->__inc_hsv_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_rgb_m = 0; else
		 __privtrans->__inc_rgb_m = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_hsv_to_rgb_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_hsv_to_rgb_struct *__privtrans = (pdl_hsv_to_rgb_struct *) __tr;
	
	{
	    pdl_hsv_to_rgb_struct *__copy = malloc(sizeof(pdl_hsv_to_rgb_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_hsv_n=__copy->__inc_hsv_n;__privtrans->__inc_rgb_m=__copy->__inc_rgb_m;__copy->__n_size=__privtrans->__n_size;__copy->__m_size=__privtrans->__m_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_hsv_to_rgb_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_hsv_to_rgb_struct *__privtrans = (pdl_hsv_to_rgb_struct *) __tr;
	
	{
	    {register int __m_size = __privtrans->__m_size;
/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_S: {
	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_US: {
	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_L: {
	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_LL: {
	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_F: {
	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Float v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_D: {
	PDL_Double * hsv_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * hsv_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   hsv_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Double v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == hsv_badval || (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == hsv_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = rgb_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			}
			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_n = __privtrans->__inc_hsv_n;
register PDL_Long __inc_rgb_m = __privtrans->__inc_rgb_m;


		PDL_Double v, s, h, f, w, q, t;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];hsv_datap += __offsp[0];
rgb_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and adjust the value */
			v = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (v > 1) v = 1;
			if (v < 0) v = 0;
			/* Set value to something between 0 and 255 */
			v *= 255;
			
			/* Get and adjust the saturation */
			s = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (s > 1) s = 1;
			if (s < 0) s = 0;
			
			/* handle the special case of zero saturation */
			if (s == 0) {
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
				(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				/* Get and adjust the hue */
				h = (hsv_datap)[0+(__inc_hsv_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
				if (h < 0) h = 0;
				if (h > 360) h = 360;
				
				/* Adjust hue to run between 0 and 4 instead of 0 and 360 */
				h /= 60;
				
				/* To help understand this, see */
				/* en.wikipedia.org/wiki/HSL_and_HSV#From_HSV */
				i = (int) h;
				f = h - i;
				w = v * (1 - s);
				q = v * (1 - (s * f));
				t = v * (1 - (s * (1 - f)));
				
				if (i == 0) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 1) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = w;
				}
				else if (i == 2) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = t;
				}
				else if (i == 3) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = q;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else if (i == 4) {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = t;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
				}
				else {
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = v;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = w;
					(rgb_datap)[0+(__inc_rgb_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = q;
				}
			}

			/* THREADLOOPEND */
	 hsv_datap += __tinc0_0;
rgb_datap += __tinc0_1;

	 } hsv_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
rgb_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} hsv_datap -= __tinc1_0 *
     				  __tdims1;rgb_datap -= __tinc1_1 *
     				  __tdims1;
 hsv_datap -= __offsp[0];
rgb_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_hsv_to_rgb_free(pdl_trans *__tr ) {
	int __dim;
	pdl_hsv_to_rgb_struct *__privtrans = (pdl_hsv_to_rgb_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_hsv_to_rgb_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_hsv_to_rgb_vtable = {
		0,0, 1, 2, pdl_hsv_to_rgb_vtable_flags,
		pdl_hsv_to_rgb_redodims, pdl_hsv_to_rgb_readdata, NULL,
		pdl_hsv_to_rgb_free,NULL,NULL,pdl_hsv_to_rgb_copy,NULL,
		sizeof(pdl_hsv_to_rgb_struct),"pdl_hsv_to_rgb_vtable",
		NULL
	 };

typedef struct pdl_rgb_to_hsv_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_rgb_n;PDL_Long  __inc_hsv_m;PDL_Long  __n_size;PDL_Long  __m_size;
		
		char __ddone; /* Dims done */
		} pdl_rgb_to_hsv_struct;

void pdl_rgb_to_hsv_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_hsv_struct *__privtrans = (pdl_rgb_to_hsv_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = 3;
__privtrans->__m_size = 3;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"rgb","hsv"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::rgb_to_hsv";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rgb_to_hsv:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__m_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rgb_to_hsv:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__m_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_rgb_n = 0; else
		 __privtrans->__inc_rgb_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_hsv_m = 0; else
		 __privtrans->__inc_hsv_m = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_rgb_to_hsv_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_hsv_struct *__privtrans = (pdl_rgb_to_hsv_struct *) __tr;
	
	{
	    pdl_rgb_to_hsv_struct *__copy = malloc(sizeof(pdl_rgb_to_hsv_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_rgb_n=__copy->__inc_rgb_n;__privtrans->__inc_hsv_m=__copy->__inc_hsv_m;__copy->__n_size=__privtrans->__n_size;__copy->__m_size=__privtrans->__m_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_rgb_to_hsv_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_hsv_struct *__privtrans = (pdl_rgb_to_hsv_struct *) __tr;
	
	{
	    {register int __m_size = __privtrans->__m_size;
/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_S: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_US: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_L: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_LL: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_F: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * hsv_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * hsv_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   hsv_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Float r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	} break; case PDL_D: {
	PDL_Long * rgb_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * rgb_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   rgb_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Double * hsv_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * hsv_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	PDL_Double   hsv_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Double r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* First check for bad values */
			if ((rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  == rgb_badval || (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */  == rgb_badval) {
				{/* Open m */ register int m;
			for(m=0; m<(__m_size); m++) {
					(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, m))] /* ACCESS() */  = hsv_badval;
				}} /* Close m */
				/* skip to the next hsv triple */
			}
			else {
			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			}
			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
{register PDL_Long __inc_hsv_m = __privtrans->__inc_hsv_m;
register PDL_Long __inc_rgb_n = __privtrans->__inc_rgb_n;


		PDL_Double r, g, b, h, s, v, max, min, delta;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];rgb_datap += __offsp[0];
hsv_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			
			/* Get and rescale the rgb values */
			r = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			if (r < 0) r = 0;
			if (r > 255) r = 255;
			r /= 255.0;
			g = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			if (g < 0) g = 0;
			if (g > 255) g = 255;
			g /= 255.0;
			b = (rgb_datap)[0+(__inc_rgb_n*PP_INDTERM(__privtrans->__n_size, 2))] /* ACCESS() */ ;
			if (b < 0) b = 0;
			if (b > 255) b = 255;
			b /= 255.0;
			
			/* compute the min and max */
			max = r;
			if (max < g) max = g;
			if (max < b) max = b;
			min = r;
			if (g < min) min = g;
			if (b < min) min = b;
			
			/* Set the value and delta */
			v = max;
			delta = max - min;
			
			/* set up a greyscale if rgb values are identical */
			/* Note: automatically includes max = 0 */
			if (delta == 0) {
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = 0;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}
			else {
				s = delta / max;
				
				/* compute hue */
				if (r == max) {
					h = (g - b) / delta;
				}
				else if (g == max) {
					h = 2 + (b - r) / delta;
				}
				else {
					h = 4 + (r - g) / delta;
				}
				h *= 60;
				if (h < 0) h += 360;
				
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 0))] /* ACCESS() */  = h;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 1))] /* ACCESS() */  = s;
				(hsv_datap)[0+(__inc_hsv_m*PP_INDTERM(__privtrans->__m_size, 2))] /* ACCESS() */  = v;
			}

			/* THREADLOOPEND */
	 rgb_datap += __tinc0_0;
hsv_datap += __tinc0_1;

	 } rgb_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
hsv_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} rgb_datap -= __tinc1_0 *
     				  __tdims1;hsv_datap -= __tinc1_1 *
     				  __tdims1;
 rgb_datap -= __offsp[0];
hsv_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}}
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_rgb_to_hsv_free(pdl_trans *__tr ) {
	int __dim;
	pdl_rgb_to_hsv_struct *__privtrans = (pdl_rgb_to_hsv_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_rgb_to_hsv_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_rgb_to_hsv_vtable = {
		0,0, 1, 2, pdl_rgb_to_hsv_vtable_flags,
		pdl_rgb_to_hsv_redodims, pdl_rgb_to_hsv_readdata, NULL,
		pdl_rgb_to_hsv_free,NULL,NULL,pdl_rgb_to_hsv_copy,NULL,
		sizeof(pdl_rgb_to_hsv_struct),"pdl_rgb_to_hsv_vtable",
		NULL
	 };


#include <float.h>
#include <limits.h>
typedef struct pdl_minmaxforpair_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Long  __inc_x_n;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl_minmaxforpair_struct;

void pdl_minmaxforpair_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_minmaxforpair_struct *__privtrans = (pdl_minmaxforpair_struct *) __tr;
	
	{
	    int __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"x","y","min_x","min_y","max_x","max_y"};
		static int __realdims[] = {1,1,0,0,0,0};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::minmaxforpair";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in minmaxforpair:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in minmaxforpair:" "Wrong dims\n");
      }
   }
if(!__creating[2]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv && 
	 (__privtrans->pdls[2]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv && 
	 (__privtrans->pdls[3]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv && 
	 (__privtrans->pdls[4]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv && 
	 (__privtrans->pdls[5]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[5]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_x_n = 0; else
		 __privtrans->__inc_x_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_minmaxforpair_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_minmaxforpair_struct *__privtrans = (pdl_minmaxforpair_struct *) __tr;
	
	{
	    pdl_minmaxforpair_struct *__copy = malloc(sizeof(pdl_minmaxforpair_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_x_n=__copy->__inc_x_n;__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_minmaxforpair_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_minmaxforpair_struct *__privtrans = (pdl_minmaxforpair_struct *) __tr;
	
	{
	    {register int __n_size = __privtrans->__n_size;
/* Start generic loop */
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_B
#define THISIS_B(a) a
	PDL_Byte * x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * x_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	PDL_Byte   x_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));
	PDL_Byte   y_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Byte * min_x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * min_x_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	PDL_Byte   min_x_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Byte * min_y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * min_y_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));
	PDL_Byte   min_y_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Byte * max_x_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Byte * max_x_physdatap = ((PDL_Byte *)((__privtrans->pdls[4])->data));
	PDL_Byte   max_x_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Byte * max_y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Byte * max_y_physdatap = ((PDL_Byte *)((__privtrans->pdls[5])->data));
	PDL_Byte   max_y_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = SCHAR_MAX;
		(max_x_datap)[0] /* ACCESS() */  = SCHAR_MIN;
		(min_y_datap)[0] /* ACCESS() */  = SCHAR_MAX;
		(max_y_datap)[0] /* ACCESS() */  = SCHAR_MIN;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_S: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_S
#define THISIS_S(a) a
	PDL_Short * x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * x_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	PDL_Short   x_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));
	PDL_Short   y_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Short * min_x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * min_x_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	PDL_Short   min_x_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Short * min_y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * min_y_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));
	PDL_Short   min_y_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Short * max_x_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Short * max_x_physdatap = ((PDL_Short *)((__privtrans->pdls[4])->data));
	PDL_Short   max_x_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Short * max_y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Short * max_y_physdatap = ((PDL_Short *)((__privtrans->pdls[5])->data));
	PDL_Short   max_y_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = SHRT_MAX;
		(max_x_datap)[0] /* ACCESS() */  = SHRT_MIN;
		(min_y_datap)[0] /* ACCESS() */  = SHRT_MAX;
		(max_y_datap)[0] /* ACCESS() */  = SHRT_MIN;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_US: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_U
#define THISIS_U(a) a
	PDL_Ushort * x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	PDL_Ushort   x_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));
	PDL_Ushort   y_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Ushort * min_x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * min_x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	PDL_Ushort   min_x_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Ushort * min_y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * min_y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));
	PDL_Ushort   min_y_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Ushort * max_x_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Ushort * max_x_physdatap = ((PDL_Ushort *)((__privtrans->pdls[4])->data));
	PDL_Ushort   max_x_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Ushort * max_y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Ushort * max_y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[5])->data));
	PDL_Ushort   max_y_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = USHRT_MAX;
		(max_x_datap)[0] /* ACCESS() */  = 0;
		(min_y_datap)[0] /* ACCESS() */  = USHRT_MAX;
		(max_y_datap)[0] /* ACCESS() */  = 0;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_L: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_L
#define THISIS_L(a) a
	PDL_Long * x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * x_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   x_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   y_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Long * min_x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * min_x_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	PDL_Long   min_x_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * min_y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * min_y_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   min_y_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Long * max_x_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * max_x_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));
	PDL_Long   max_x_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Long * max_y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * max_y_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));
	PDL_Long   max_y_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = INT_MAX;
		(max_x_datap)[0] /* ACCESS() */  = INT_MIN;
		(min_y_datap)[0] /* ACCESS() */  = INT_MAX;
		(max_y_datap)[0] /* ACCESS() */  = INT_MIN;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_LL: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_Q
#define THISIS_Q(a) a
	PDL_LongLong * x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));
	PDL_LongLong   x_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));
	PDL_LongLong   y_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_LongLong * min_x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * min_x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));
	PDL_LongLong   min_x_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_LongLong * min_y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * min_y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));
	PDL_LongLong   min_y_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_LongLong * max_x_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_LongLong * max_x_physdatap = ((PDL_LongLong *)((__privtrans->pdls[4])->data));
	PDL_LongLong   max_x_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_LongLong * max_y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_LongLong * max_y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[5])->data));
	PDL_LongLong   max_y_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = LLONG_MAX;
		(max_x_datap)[0] /* ACCESS() */  = LLONG_MIN;
		(min_y_datap)[0] /* ACCESS() */  = LLONG_MAX;
		(max_y_datap)[0] /* ACCESS() */  = LLONG_MIN;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_F: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_F
#define THISIS_F(a) a
	PDL_Float * x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * x_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   x_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));
	PDL_Float   y_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Float * min_x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * min_x_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	PDL_Float   min_x_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Float * min_y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * min_y_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));
	PDL_Float   min_y_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Float * max_x_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Float * max_x_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	PDL_Float   max_x_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Float * max_y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Float * max_y_physdatap = ((PDL_Float *)((__privtrans->pdls[5])->data));
	PDL_Float   max_y_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = FLT_MAX;
		(max_x_datap)[0] /* ACCESS() */  = FLT_MIN;
		(min_y_datap)[0] /* ACCESS() */  = FLT_MAX;
		(max_y_datap)[0] /* ACCESS() */  = FLT_MIN;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_D: {
#undef THISIS_B
#define THISIS_B(a)
#undef THISIS_S
#define THISIS_S(a)
#undef THISIS_U
#define THISIS_U(a)
#undef THISIS_L
#define THISIS_L(a)
#undef THISIS_Q
#define THISIS_Q(a)
#undef THISIS_F
#define THISIS_F(a)
#undef THISIS_D
#define THISIS_D(a)
#undef THISIS_D
#define THISIS_D(a) a
	PDL_Double * x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * x_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));
	PDL_Double   y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Double * min_x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * min_x_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	PDL_Double   min_x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Double * min_y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * min_y_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));
	PDL_Double   min_y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Double * max_x_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * max_x_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	PDL_Double   max_x_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Double * max_y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * max_y_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));
	PDL_Double   max_y_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


		// For bad code, I can't set initial values for min/max as the first
		// elements of x/y. In fact, I need to assume that possibly all the data
		// could be bad, so start with that:
		(min_x_datap)[0] /* ACCESS() */  = min_x_badval;
		(max_x_datap)[0] /* ACCESS() */  = max_x_badval;
		(min_y_datap)[0] /* ACCESS() */  = min_y_badval;
		(max_y_datap)[0] /* ACCESS() */  = max_y_badval;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			// Only check (and possibly change) if both x and y are good:
			if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != x_badval && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  != y_badval				/* bad check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 			/* nan check */
					&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
				// It could be that this is the first good value. If so, just
				// assign the value. Note that either all min/max value are bad,
				// or they are good, so I only need to check one of them (min_x
				// in this case):
				if ((min_x_datap)[0] /* ACCESS() */  == min_x_badval) {
					(min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					(max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
				// If the min/max values are good, then I need to perform a
				// bona-fide comparison:
				else {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			}
		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 } else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];x_datap += __offsp[0];
y_datap += __offsp[1];
min_x_datap += __offsp[2];
min_y_datap += __offsp[3];
max_x_datap += __offsp[4];
max_y_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;
register PDL_Long __inc_x_n = __privtrans->__inc_x_n;


						(min_x_datap)[0] /* ACCESS() */  = DBL_MAX;
		(max_x_datap)[0] /* ACCESS() */  = DBL_MIN;
		(min_y_datap)[0] /* ACCESS() */  = DBL_MAX;
		(max_y_datap)[0] /* ACCESS() */  = DBL_MIN;
		
		{/* Open n */ register int n;
			for(n=0; n<(__n_size); n++) {
			
#if (THISIS_B(1)+0)||(THISIS_S(1)+0)||(THISIS_U(1)+0)||(THISIS_L(1)+0)||(THISIS_Q(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
			
#endif

			
#if (THISIS_F(1)+0)||(THISIS_D(1)+0)

				if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  == (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ 				/* nan check */
						&& (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0 && (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ *0.0 == 0.0	/* inf check */
				) {
					if ((x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_x_datap)[0] /* ACCESS() */ ) (min_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_x_datap)[0] /* ACCESS() */  < (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_x_datap)[0] /* ACCESS() */  = (x_datap)[0+(__inc_x_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */  < (min_y_datap)[0] /* ACCESS() */ ) (min_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
					if ((max_y_datap)[0] /* ACCESS() */  < (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ) (max_y_datap)[0] /* ACCESS() */  = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, n))] /* ACCESS() */ ;
				}
			
#endif

		}} /* Close n */
	
}	/* THREADLOOPEND */
	 x_datap += __tinc0_0;
y_datap += __tinc0_1;
min_x_datap += __tinc0_2;
min_y_datap += __tinc0_3;
max_x_datap += __tinc0_4;
max_y_datap += __tinc0_5;

	 } x_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
y_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
min_x_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
min_y_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
max_x_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
max_y_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} x_datap -= __tinc1_0 *
     				  __tdims1;y_datap -= __tinc1_1 *
     				  __tdims1;min_x_datap -= __tinc1_2 *
     				  __tdims1;min_y_datap -= __tinc1_3 *
     				  __tdims1;max_x_datap -= __tinc1_4 *
     				  __tdims1;max_y_datap -= __tinc1_5 *
     				  __tdims1;
 x_datap -= __offsp[0];
y_datap -= __offsp[1];
min_x_datap -= __offsp[2];
min_y_datap -= __offsp[3];
max_x_datap -= __offsp[4];
max_y_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_minmaxforpair_free(pdl_trans *__tr ) {
	int __dim;
	pdl_minmaxforpair_struct *__privtrans = (pdl_minmaxforpair_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl_minmaxforpair_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_minmaxforpair_vtable = {
		0,0, 2, 6, pdl_minmaxforpair_vtable_flags,
		pdl_minmaxforpair_redodims, pdl_minmaxforpair_readdata, NULL,
		pdl_minmaxforpair_free,NULL,NULL,pdl_minmaxforpair_copy,NULL,
		sizeof(pdl_minmaxforpair_struct),"pdl_minmaxforpair_vtable",
		NULL
	 };

typedef struct pdl_collate_min_max_wrt_many_struct {
		PDL_TRANS_START(26);
		pdl_thread  __pdlthread;PDL_Long  __inc_min_check_Q;PDL_Long  __inc_min_index_Q;PDL_Long  __inc_max_check_Q;PDL_Long  __inc_max_index_Q;PDL_Long  __inc_extra0_Q;PDL_Long  __inc_extra1_Q;PDL_Long  __inc_extra2_Q;PDL_Long  __inc_extra3_Q;PDL_Long  __inc_extra4_Q;PDL_Long  __inc_extra5_Q;PDL_Long  __inc_extra6_Q;PDL_Long  __inc_extra7_Q;PDL_Long  __inc_extra8_Q;PDL_Long  __inc_extra9_Q;PDL_Long  __inc_extra10_Q;PDL_Long  __inc_extra11_Q;PDL_Long  __inc_extra12_Q;PDL_Long  __inc_extra13_Q;PDL_Long  __inc_extra14_Q;PDL_Long  __inc_extra15_Q;PDL_Long  __inc_extra16_Q;PDL_Long  __inc_extra17_Q;PDL_Long  __inc_extra18_Q;PDL_Long  __inc_extra19_Q;PDL_Long  __inc_min_N;PDL_Long  __inc_max_N;PDL_Long  __Q_size;PDL_Long  __N_size;
		int  N_extras;
		char __ddone; /* Dims done */
		} pdl_collate_min_max_wrt_many_struct;

void pdl_collate_min_max_wrt_many_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_collate_min_max_wrt_many_struct *__privtrans = (pdl_collate_min_max_wrt_many_struct *) __tr;
	
	{
	    int __creating[26];
__privtrans->__Q_size = -1;
__privtrans->__N_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = 0;
__creating[10] = 0;
__creating[11] = 0;
__creating[12] = 0;
__creating[13] = 0;
__creating[14] = 0;
__creating[15] = 0;
__creating[16] = 0;
__creating[17] = 0;
__creating[18] = 0;
__creating[19] = 0;
__creating[20] = 0;
__creating[21] = 0;
__creating[22] = 0;
__creating[23] = 0;
__creating[24] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[24]);
__creating[25] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[25]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"min_check","min_index","max_check","max_index","extra0","extra1","extra2","extra3","extra4","extra5","extra6","extra7","extra8","extra9","extra10","extra11","extra12","extra13","extra14","extra15","extra16","extra17","extra18","extra19","min","max"};
		static int __realdims[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::collate_min_max_wrt_many";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 26
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,26,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[6]))->ndims < 1) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[7]))->ndims < 1) {
      if (((__privtrans->pdls[7]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[7]))->dims[0];
   } else if(((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[7]))->dims[0]) {
      if(((__privtrans->pdls[7]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[8]))->ndims < 1) {
      if (((__privtrans->pdls[8]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[8]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[8]))->dims[0];
   } else if(((__privtrans->pdls[8]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[8]))->dims[0]) {
      if(((__privtrans->pdls[8]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[9]))->ndims < 1) {
      if (((__privtrans->pdls[9]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[9]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[9]))->dims[0];
   } else if(((__privtrans->pdls[9]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[9]))->dims[0]) {
      if(((__privtrans->pdls[9]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[10]))->ndims < 1) {
      if (((__privtrans->pdls[10]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[10]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[10]))->dims[0];
   } else if(((__privtrans->pdls[10]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[10]))->dims[0]) {
      if(((__privtrans->pdls[10]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[11]))->ndims < 1) {
      if (((__privtrans->pdls[11]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[11]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[11]))->dims[0];
   } else if(((__privtrans->pdls[11]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[11]))->dims[0]) {
      if(((__privtrans->pdls[11]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[12]))->ndims < 1) {
      if (((__privtrans->pdls[12]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[12]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[12]))->dims[0];
   } else if(((__privtrans->pdls[12]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[12]))->dims[0]) {
      if(((__privtrans->pdls[12]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[13]))->ndims < 1) {
      if (((__privtrans->pdls[13]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[13]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[13]))->dims[0];
   } else if(((__privtrans->pdls[13]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[13]))->dims[0]) {
      if(((__privtrans->pdls[13]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[14]))->ndims < 1) {
      if (((__privtrans->pdls[14]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[14]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[14]))->dims[0];
   } else if(((__privtrans->pdls[14]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[14]))->dims[0]) {
      if(((__privtrans->pdls[14]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[15]))->ndims < 1) {
      if (((__privtrans->pdls[15]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[15]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[15]))->dims[0];
   } else if(((__privtrans->pdls[15]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[15]))->dims[0]) {
      if(((__privtrans->pdls[15]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[16]))->ndims < 1) {
      if (((__privtrans->pdls[16]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[16]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[16]))->dims[0];
   } else if(((__privtrans->pdls[16]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[16]))->dims[0]) {
      if(((__privtrans->pdls[16]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[17]))->ndims < 1) {
      if (((__privtrans->pdls[17]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[17]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[17]))->dims[0];
   } else if(((__privtrans->pdls[17]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[17]))->dims[0]) {
      if(((__privtrans->pdls[17]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[18]))->ndims < 1) {
      if (((__privtrans->pdls[18]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[18]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[18]))->dims[0];
   } else if(((__privtrans->pdls[18]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[18]))->dims[0]) {
      if(((__privtrans->pdls[18]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[19]))->ndims < 1) {
      if (((__privtrans->pdls[19]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[19]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[19]))->dims[0];
   } else if(((__privtrans->pdls[19]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[19]))->dims[0]) {
      if(((__privtrans->pdls[19]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[20]))->ndims < 1) {
      if (((__privtrans->pdls[20]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[20]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[20]))->dims[0];
   } else if(((__privtrans->pdls[20]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[20]))->dims[0]) {
      if(((__privtrans->pdls[20]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[21]))->ndims < 1) {
      if (((__privtrans->pdls[21]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[21]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[21]))->dims[0];
   } else if(((__privtrans->pdls[21]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[21]))->dims[0]) {
      if(((__privtrans->pdls[21]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[22]))->ndims < 1) {
      if (((__privtrans->pdls[22]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[22]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[22]))->dims[0];
   } else if(((__privtrans->pdls[22]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[22]))->dims[0]) {
      if(((__privtrans->pdls[22]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[23]))->ndims < 1) {
      if (((__privtrans->pdls[23]))->ndims < 1 && __privtrans->__Q_size <= 1) __privtrans->__Q_size = 1;
   }
   if(__privtrans->__Q_size == -1 || (((__privtrans->pdls[23]))->ndims > 0 && __privtrans->__Q_size == 1)) {
      __privtrans->__Q_size = ((__privtrans->pdls[23]))->dims[0];
   } else if(((__privtrans->pdls[23]))->ndims > 0 && __privtrans->__Q_size != ((__privtrans->pdls[23]))->dims[0]) {
      if(((__privtrans->pdls[23]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
if(!__creating[24]) {
   if(((__privtrans->pdls[24]))->ndims < 1) {
      if (((__privtrans->pdls[24]))->ndims < 1 && __privtrans->__N_size <= 1) __privtrans->__N_size = 1;
   }
   if(__privtrans->__N_size == -1 || (((__privtrans->pdls[24]))->ndims > 0 && __privtrans->__N_size == 1)) {
      __privtrans->__N_size = ((__privtrans->pdls[24]))->dims[0];
   } else if(((__privtrans->pdls[24]))->ndims > 0 && __privtrans->__N_size != ((__privtrans->pdls[24]))->dims[0]) {
      if(((__privtrans->pdls[24]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__N_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,24,dims,0);
}if(!__creating[25]) {
   if(((__privtrans->pdls[25]))->ndims < 1) {
      if (((__privtrans->pdls[25]))->ndims < 1 && __privtrans->__N_size <= 1) __privtrans->__N_size = 1;
   }
   if(__privtrans->__N_size == -1 || (((__privtrans->pdls[25]))->ndims > 0 && __privtrans->__N_size == 1)) {
      __privtrans->__N_size = ((__privtrans->pdls[25]))->dims[0];
   } else if(((__privtrans->pdls[25]))->ndims > 0 && __privtrans->__N_size != ((__privtrans->pdls[25]))->dims[0]) {
      if(((__privtrans->pdls[25]))->dims[0] != 1) {
         PDL->pdl_barf("Error in collate_min_max_wrt_many:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__N_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,25,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[2]->hdrsv && 
	 (__privtrans->pdls[2]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[3]->hdrsv && 
	 (__privtrans->pdls[3]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[4]->hdrsv && 
	 (__privtrans->pdls[4]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[5]->hdrsv && 
	 (__privtrans->pdls[5]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[6]->hdrsv && 
	 (__privtrans->pdls[6]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[7]->hdrsv && 
	 (__privtrans->pdls[7]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[8]->hdrsv && 
	 (__privtrans->pdls[8]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[9]->hdrsv && 
	 (__privtrans->pdls[9]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[10]->hdrsv && 
	 (__privtrans->pdls[10]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[10]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[10]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[11]->hdrsv && 
	 (__privtrans->pdls[11]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[11]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[11]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[12]->hdrsv && 
	 (__privtrans->pdls[12]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[12]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[12]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[13]->hdrsv && 
	 (__privtrans->pdls[13]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[13]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[13]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[14]->hdrsv && 
	 (__privtrans->pdls[14]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[14]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[14]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[15]->hdrsv && 
	 (__privtrans->pdls[15]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[15]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[15]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[16]->hdrsv && 
	 (__privtrans->pdls[16]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[16]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[16]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[17]->hdrsv && 
	 (__privtrans->pdls[17]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[17]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[17]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[18]->hdrsv && 
	 (__privtrans->pdls[18]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[18]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[18]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[19]->hdrsv && 
	 (__privtrans->pdls[19]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[19]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[19]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[20]->hdrsv && 
	 (__privtrans->pdls[20]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[20]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[20]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[21]->hdrsv && 
	 (__privtrans->pdls[21]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[21]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[21]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[22]->hdrsv && 
	 (__privtrans->pdls[22]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[22]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[22]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	      __privtrans->pdls[23]->hdrsv && 
	 (__privtrans->pdls[23]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[23]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[23]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[24] && 
     __privtrans->pdls[24]->hdrsv && 
	 (__privtrans->pdls[24]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[24]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[24]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[25] && 
     __privtrans->pdls[25]->hdrsv && 
	 (__privtrans->pdls[25]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[25]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[25]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[24]->hdrsv != hdrp ){
	 if( __privtrans->pdls[24]->hdrsv && __privtrans->pdls[24]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[24]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[24]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[24]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[25]->hdrsv != hdrp ){
	 if( __privtrans->pdls[25]->hdrsv && __privtrans->pdls[25]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[25]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[25]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[25]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_min_check_Q = 0; else
		 __privtrans->__inc_min_check_Q = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_min_index_Q = 0; else
		 __privtrans->__inc_min_index_Q = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_max_check_Q = 0; else
		 __privtrans->__inc_max_check_Q = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_max_index_Q = 0; else
		 __privtrans->__inc_max_index_Q = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_extra0_Q = 0; else
		 __privtrans->__inc_extra0_Q = PDL_REPRINC(__privtrans->pdls[4],0);if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_extra1_Q = 0; else
		 __privtrans->__inc_extra1_Q = PDL_REPRINC(__privtrans->pdls[5],0);if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_extra2_Q = 0; else
		 __privtrans->__inc_extra2_Q = PDL_REPRINC(__privtrans->pdls[6],0);if(__privtrans->pdls[7]->ndims <= 0 || __privtrans->pdls[7]->dims[0] <= 1)
		  __privtrans->__inc_extra3_Q = 0; else
		 __privtrans->__inc_extra3_Q = PDL_REPRINC(__privtrans->pdls[7],0);if(__privtrans->pdls[8]->ndims <= 0 || __privtrans->pdls[8]->dims[0] <= 1)
		  __privtrans->__inc_extra4_Q = 0; else
		 __privtrans->__inc_extra4_Q = PDL_REPRINC(__privtrans->pdls[8],0);if(__privtrans->pdls[9]->ndims <= 0 || __privtrans->pdls[9]->dims[0] <= 1)
		  __privtrans->__inc_extra5_Q = 0; else
		 __privtrans->__inc_extra5_Q = PDL_REPRINC(__privtrans->pdls[9],0);if(__privtrans->pdls[10]->ndims <= 0 || __privtrans->pdls[10]->dims[0] <= 1)
		  __privtrans->__inc_extra6_Q = 0; else
		 __privtrans->__inc_extra6_Q = PDL_REPRINC(__privtrans->pdls[10],0);if(__privtrans->pdls[11]->ndims <= 0 || __privtrans->pdls[11]->dims[0] <= 1)
		  __privtrans->__inc_extra7_Q = 0; else
		 __privtrans->__inc_extra7_Q = PDL_REPRINC(__privtrans->pdls[11],0);if(__privtrans->pdls[12]->ndims <= 0 || __privtrans->pdls[12]->dims[0] <= 1)
		  __privtrans->__inc_extra8_Q = 0; else
		 __privtrans->__inc_extra8_Q = PDL_REPRINC(__privtrans->pdls[12],0);if(__privtrans->pdls[13]->ndims <= 0 || __privtrans->pdls[13]->dims[0] <= 1)
		  __privtrans->__inc_extra9_Q = 0; else
		 __privtrans->__inc_extra9_Q = PDL_REPRINC(__privtrans->pdls[13],0);if(__privtrans->pdls[14]->ndims <= 0 || __privtrans->pdls[14]->dims[0] <= 1)
		  __privtrans->__inc_extra10_Q = 0; else
		 __privtrans->__inc_extra10_Q = PDL_REPRINC(__privtrans->pdls[14],0);if(__privtrans->pdls[15]->ndims <= 0 || __privtrans->pdls[15]->dims[0] <= 1)
		  __privtrans->__inc_extra11_Q = 0; else
		 __privtrans->__inc_extra11_Q = PDL_REPRINC(__privtrans->pdls[15],0);if(__privtrans->pdls[16]->ndims <= 0 || __privtrans->pdls[16]->dims[0] <= 1)
		  __privtrans->__inc_extra12_Q = 0; else
		 __privtrans->__inc_extra12_Q = PDL_REPRINC(__privtrans->pdls[16],0);if(__privtrans->pdls[17]->ndims <= 0 || __privtrans->pdls[17]->dims[0] <= 1)
		  __privtrans->__inc_extra13_Q = 0; else
		 __privtrans->__inc_extra13_Q = PDL_REPRINC(__privtrans->pdls[17],0);if(__privtrans->pdls[18]->ndims <= 0 || __privtrans->pdls[18]->dims[0] <= 1)
		  __privtrans->__inc_extra14_Q = 0; else
		 __privtrans->__inc_extra14_Q = PDL_REPRINC(__privtrans->pdls[18],0);if(__privtrans->pdls[19]->ndims <= 0 || __privtrans->pdls[19]->dims[0] <= 1)
		  __privtrans->__inc_extra15_Q = 0; else
		 __privtrans->__inc_extra15_Q = PDL_REPRINC(__privtrans->pdls[19],0);if(__privtrans->pdls[20]->ndims <= 0 || __privtrans->pdls[20]->dims[0] <= 1)
		  __privtrans->__inc_extra16_Q = 0; else
		 __privtrans->__inc_extra16_Q = PDL_REPRINC(__privtrans->pdls[20],0);if(__privtrans->pdls[21]->ndims <= 0 || __privtrans->pdls[21]->dims[0] <= 1)
		  __privtrans->__inc_extra17_Q = 0; else
		 __privtrans->__inc_extra17_Q = PDL_REPRINC(__privtrans->pdls[21],0);if(__privtrans->pdls[22]->ndims <= 0 || __privtrans->pdls[22]->dims[0] <= 1)
		  __privtrans->__inc_extra18_Q = 0; else
		 __privtrans->__inc_extra18_Q = PDL_REPRINC(__privtrans->pdls[22],0);if(__privtrans->pdls[23]->ndims <= 0 || __privtrans->pdls[23]->dims[0] <= 1)
		  __privtrans->__inc_extra19_Q = 0; else
		 __privtrans->__inc_extra19_Q = PDL_REPRINC(__privtrans->pdls[23],0);if(__privtrans->pdls[24]->ndims <= 0 || __privtrans->pdls[24]->dims[0] <= 1)
		  __privtrans->__inc_min_N = 0; else
		 __privtrans->__inc_min_N = PDL_REPRINC(__privtrans->pdls[24],0);if(__privtrans->pdls[25]->ndims <= 0 || __privtrans->pdls[25]->dims[0] <= 1)
		  __privtrans->__inc_max_N = 0; else
		 __privtrans->__inc_max_N = PDL_REPRINC(__privtrans->pdls[25],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_collate_min_max_wrt_many_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_collate_min_max_wrt_many_struct *__privtrans = (pdl_collate_min_max_wrt_many_struct *) __tr;
	
	{
	    pdl_collate_min_max_wrt_many_struct *__copy = malloc(sizeof(pdl_collate_min_max_wrt_many_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->N_extras) = (__privtrans->N_extras);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_min_check_Q=__copy->__inc_min_check_Q;__privtrans->__inc_min_index_Q=__copy->__inc_min_index_Q;__privtrans->__inc_max_check_Q=__copy->__inc_max_check_Q;__privtrans->__inc_max_index_Q=__copy->__inc_max_index_Q;__privtrans->__inc_extra0_Q=__copy->__inc_extra0_Q;__privtrans->__inc_extra1_Q=__copy->__inc_extra1_Q;__privtrans->__inc_extra2_Q=__copy->__inc_extra2_Q;__privtrans->__inc_extra3_Q=__copy->__inc_extra3_Q;__privtrans->__inc_extra4_Q=__copy->__inc_extra4_Q;__privtrans->__inc_extra5_Q=__copy->__inc_extra5_Q;__privtrans->__inc_extra6_Q=__copy->__inc_extra6_Q;__privtrans->__inc_extra7_Q=__copy->__inc_extra7_Q;__privtrans->__inc_extra8_Q=__copy->__inc_extra8_Q;__privtrans->__inc_extra9_Q=__copy->__inc_extra9_Q;__privtrans->__inc_extra10_Q=__copy->__inc_extra10_Q;__privtrans->__inc_extra11_Q=__copy->__inc_extra11_Q;__privtrans->__inc_extra12_Q=__copy->__inc_extra12_Q;__privtrans->__inc_extra13_Q=__copy->__inc_extra13_Q;__privtrans->__inc_extra14_Q=__copy->__inc_extra14_Q;__privtrans->__inc_extra15_Q=__copy->__inc_extra15_Q;__privtrans->__inc_extra16_Q=__copy->__inc_extra16_Q;__privtrans->__inc_extra17_Q=__copy->__inc_extra17_Q;__privtrans->__inc_extra18_Q=__copy->__inc_extra18_Q;__privtrans->__inc_extra19_Q=__copy->__inc_extra19_Q;__privtrans->__inc_min_N=__copy->__inc_min_N;__privtrans->__inc_max_N=__copy->__inc_max_N;__copy->__Q_size=__privtrans->__Q_size;__copy->__N_size=__privtrans->__N_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_collate_min_max_wrt_many_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_collate_min_max_wrt_many_struct *__privtrans = (pdl_collate_min_max_wrt_many_struct *) __tr;
	
	{
	    {register int __Q_size = __privtrans->__Q_size;
/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * min_check_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * min_check_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));
	PDL_Byte   min_check_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Byte * max_check_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * max_check_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));
	PDL_Byte   max_check_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Byte * extra0_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Byte * extra0_physdatap = ((PDL_Byte *)((__privtrans->pdls[4])->data));
	PDL_Byte   extra0_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Byte * extra1_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Byte * extra1_physdatap = ((PDL_Byte *)((__privtrans->pdls[5])->data));
	PDL_Byte   extra1_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_Byte * extra2_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Byte * extra2_physdatap = ((PDL_Byte *)((__privtrans->pdls[6])->data));
	PDL_Byte   extra2_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_Byte * extra3_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Byte * extra3_physdatap = ((PDL_Byte *)((__privtrans->pdls[7])->data));
	PDL_Byte   extra3_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_Byte * extra4_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Byte * extra4_physdatap = ((PDL_Byte *)((__privtrans->pdls[8])->data));
	PDL_Byte   extra4_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_Byte * extra5_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Byte * extra5_physdatap = ((PDL_Byte *)((__privtrans->pdls[9])->data));
	PDL_Byte   extra5_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_Byte * extra6_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Byte * extra6_physdatap = ((PDL_Byte *)((__privtrans->pdls[10])->data));
	PDL_Byte   extra6_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_Byte * extra7_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Byte * extra7_physdatap = ((PDL_Byte *)((__privtrans->pdls[11])->data));
	PDL_Byte   extra7_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_Byte * extra8_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Byte * extra8_physdatap = ((PDL_Byte *)((__privtrans->pdls[12])->data));
	PDL_Byte   extra8_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_Byte * extra9_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Byte * extra9_physdatap = ((PDL_Byte *)((__privtrans->pdls[13])->data));
	PDL_Byte   extra9_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_Byte * extra10_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Byte * extra10_physdatap = ((PDL_Byte *)((__privtrans->pdls[14])->data));
	PDL_Byte   extra10_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_Byte * extra11_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_Byte * extra11_physdatap = ((PDL_Byte *)((__privtrans->pdls[15])->data));
	PDL_Byte   extra11_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_Byte * extra12_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_Byte * extra12_physdatap = ((PDL_Byte *)((__privtrans->pdls[16])->data));
	PDL_Byte   extra12_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_Byte * extra13_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_Byte * extra13_physdatap = ((PDL_Byte *)((__privtrans->pdls[17])->data));
	PDL_Byte   extra13_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_Byte * extra14_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_Byte * extra14_physdatap = ((PDL_Byte *)((__privtrans->pdls[18])->data));
	PDL_Byte   extra14_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_Byte * extra15_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_Byte * extra15_physdatap = ((PDL_Byte *)((__privtrans->pdls[19])->data));
	PDL_Byte   extra15_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_Byte * extra16_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_Byte * extra16_physdatap = ((PDL_Byte *)((__privtrans->pdls[20])->data));
	PDL_Byte   extra16_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_Byte * extra17_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_Byte * extra17_physdatap = ((PDL_Byte *)((__privtrans->pdls[21])->data));
	PDL_Byte   extra17_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_Byte * extra18_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_Byte * extra18_physdatap = ((PDL_Byte *)((__privtrans->pdls[22])->data));
	PDL_Byte   extra18_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_Byte * extra19_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_Byte * extra19_physdatap = ((PDL_Byte *)((__privtrans->pdls[23])->data));
	PDL_Byte   extra19_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_Byte * min_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_Byte * min_physdatap = ((PDL_Byte *)((__privtrans->pdls[24])->data));
	PDL_Byte   min_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_Byte * max_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_Byte * max_physdatap = ((PDL_Byte *)((__privtrans->pdls[25])->data));
	PDL_Byte   max_badval = (PDL_Byte) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_Byte min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_S: {
	PDL_Short * min_check_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * min_check_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));
	PDL_Short   min_check_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Short * max_check_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * max_check_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));
	PDL_Short   max_check_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Short * extra0_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Short * extra0_physdatap = ((PDL_Short *)((__privtrans->pdls[4])->data));
	PDL_Short   extra0_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Short * extra1_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Short * extra1_physdatap = ((PDL_Short *)((__privtrans->pdls[5])->data));
	PDL_Short   extra1_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_Short * extra2_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Short * extra2_physdatap = ((PDL_Short *)((__privtrans->pdls[6])->data));
	PDL_Short   extra2_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_Short * extra3_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Short * extra3_physdatap = ((PDL_Short *)((__privtrans->pdls[7])->data));
	PDL_Short   extra3_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_Short * extra4_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Short * extra4_physdatap = ((PDL_Short *)((__privtrans->pdls[8])->data));
	PDL_Short   extra4_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_Short * extra5_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Short * extra5_physdatap = ((PDL_Short *)((__privtrans->pdls[9])->data));
	PDL_Short   extra5_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_Short * extra6_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Short * extra6_physdatap = ((PDL_Short *)((__privtrans->pdls[10])->data));
	PDL_Short   extra6_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_Short * extra7_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Short * extra7_physdatap = ((PDL_Short *)((__privtrans->pdls[11])->data));
	PDL_Short   extra7_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_Short * extra8_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Short * extra8_physdatap = ((PDL_Short *)((__privtrans->pdls[12])->data));
	PDL_Short   extra8_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_Short * extra9_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Short * extra9_physdatap = ((PDL_Short *)((__privtrans->pdls[13])->data));
	PDL_Short   extra9_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_Short * extra10_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Short * extra10_physdatap = ((PDL_Short *)((__privtrans->pdls[14])->data));
	PDL_Short   extra10_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_Short * extra11_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_Short * extra11_physdatap = ((PDL_Short *)((__privtrans->pdls[15])->data));
	PDL_Short   extra11_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_Short * extra12_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_Short * extra12_physdatap = ((PDL_Short *)((__privtrans->pdls[16])->data));
	PDL_Short   extra12_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_Short * extra13_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_Short * extra13_physdatap = ((PDL_Short *)((__privtrans->pdls[17])->data));
	PDL_Short   extra13_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_Short * extra14_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_Short * extra14_physdatap = ((PDL_Short *)((__privtrans->pdls[18])->data));
	PDL_Short   extra14_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_Short * extra15_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_Short * extra15_physdatap = ((PDL_Short *)((__privtrans->pdls[19])->data));
	PDL_Short   extra15_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_Short * extra16_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_Short * extra16_physdatap = ((PDL_Short *)((__privtrans->pdls[20])->data));
	PDL_Short   extra16_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_Short * extra17_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_Short * extra17_physdatap = ((PDL_Short *)((__privtrans->pdls[21])->data));
	PDL_Short   extra17_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_Short * extra18_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_Short * extra18_physdatap = ((PDL_Short *)((__privtrans->pdls[22])->data));
	PDL_Short   extra18_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_Short * extra19_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_Short * extra19_physdatap = ((PDL_Short *)((__privtrans->pdls[23])->data));
	PDL_Short   extra19_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_Short * min_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_Short * min_physdatap = ((PDL_Short *)((__privtrans->pdls[24])->data));
	PDL_Short   min_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_Short * max_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_Short * max_physdatap = ((PDL_Short *)((__privtrans->pdls[25])->data));
	PDL_Short   max_badval = (PDL_Short) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_Short min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_US: {
	PDL_Ushort * min_check_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * min_check_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));
	PDL_Ushort   min_check_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Ushort * max_check_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * max_check_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));
	PDL_Ushort   max_check_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Ushort * extra0_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Ushort * extra0_physdatap = ((PDL_Ushort *)((__privtrans->pdls[4])->data));
	PDL_Ushort   extra0_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Ushort * extra1_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Ushort * extra1_physdatap = ((PDL_Ushort *)((__privtrans->pdls[5])->data));
	PDL_Ushort   extra1_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_Ushort * extra2_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Ushort * extra2_physdatap = ((PDL_Ushort *)((__privtrans->pdls[6])->data));
	PDL_Ushort   extra2_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_Ushort * extra3_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Ushort * extra3_physdatap = ((PDL_Ushort *)((__privtrans->pdls[7])->data));
	PDL_Ushort   extra3_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_Ushort * extra4_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Ushort * extra4_physdatap = ((PDL_Ushort *)((__privtrans->pdls[8])->data));
	PDL_Ushort   extra4_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_Ushort * extra5_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Ushort * extra5_physdatap = ((PDL_Ushort *)((__privtrans->pdls[9])->data));
	PDL_Ushort   extra5_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_Ushort * extra6_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Ushort * extra6_physdatap = ((PDL_Ushort *)((__privtrans->pdls[10])->data));
	PDL_Ushort   extra6_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_Ushort * extra7_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Ushort * extra7_physdatap = ((PDL_Ushort *)((__privtrans->pdls[11])->data));
	PDL_Ushort   extra7_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_Ushort * extra8_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Ushort * extra8_physdatap = ((PDL_Ushort *)((__privtrans->pdls[12])->data));
	PDL_Ushort   extra8_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_Ushort * extra9_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Ushort * extra9_physdatap = ((PDL_Ushort *)((__privtrans->pdls[13])->data));
	PDL_Ushort   extra9_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_Ushort * extra10_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Ushort * extra10_physdatap = ((PDL_Ushort *)((__privtrans->pdls[14])->data));
	PDL_Ushort   extra10_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_Ushort * extra11_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_Ushort * extra11_physdatap = ((PDL_Ushort *)((__privtrans->pdls[15])->data));
	PDL_Ushort   extra11_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_Ushort * extra12_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_Ushort * extra12_physdatap = ((PDL_Ushort *)((__privtrans->pdls[16])->data));
	PDL_Ushort   extra12_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_Ushort * extra13_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_Ushort * extra13_physdatap = ((PDL_Ushort *)((__privtrans->pdls[17])->data));
	PDL_Ushort   extra13_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_Ushort * extra14_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_Ushort * extra14_physdatap = ((PDL_Ushort *)((__privtrans->pdls[18])->data));
	PDL_Ushort   extra14_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_Ushort * extra15_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_Ushort * extra15_physdatap = ((PDL_Ushort *)((__privtrans->pdls[19])->data));
	PDL_Ushort   extra15_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_Ushort * extra16_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_Ushort * extra16_physdatap = ((PDL_Ushort *)((__privtrans->pdls[20])->data));
	PDL_Ushort   extra16_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_Ushort * extra17_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_Ushort * extra17_physdatap = ((PDL_Ushort *)((__privtrans->pdls[21])->data));
	PDL_Ushort   extra17_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_Ushort * extra18_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_Ushort * extra18_physdatap = ((PDL_Ushort *)((__privtrans->pdls[22])->data));
	PDL_Ushort   extra18_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_Ushort * extra19_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_Ushort * extra19_physdatap = ((PDL_Ushort *)((__privtrans->pdls[23])->data));
	PDL_Ushort   extra19_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_Ushort * min_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_Ushort * min_physdatap = ((PDL_Ushort *)((__privtrans->pdls[24])->data));
	PDL_Ushort   min_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_Ushort * max_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_Ushort * max_physdatap = ((PDL_Ushort *)((__privtrans->pdls[25])->data));
	PDL_Ushort   max_badval = (PDL_Ushort) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_Ushort min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_L: {
	PDL_Long * min_check_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * min_check_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   min_check_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Long * max_check_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * max_check_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));
	PDL_Long   max_check_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Long * extra0_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * extra0_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));
	PDL_Long   extra0_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Long * extra1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * extra1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));
	PDL_Long   extra1_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_Long * extra2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * extra2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));
	PDL_Long   extra2_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_Long * extra3_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * extra3_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));
	PDL_Long   extra3_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_Long * extra4_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * extra4_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));
	PDL_Long   extra4_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_Long * extra5_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Long * extra5_physdatap = ((PDL_Long *)((__privtrans->pdls[9])->data));
	PDL_Long   extra5_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_Long * extra6_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Long * extra6_physdatap = ((PDL_Long *)((__privtrans->pdls[10])->data));
	PDL_Long   extra6_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_Long * extra7_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Long * extra7_physdatap = ((PDL_Long *)((__privtrans->pdls[11])->data));
	PDL_Long   extra7_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_Long * extra8_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Long * extra8_physdatap = ((PDL_Long *)((__privtrans->pdls[12])->data));
	PDL_Long   extra8_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_Long * extra9_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Long * extra9_physdatap = ((PDL_Long *)((__privtrans->pdls[13])->data));
	PDL_Long   extra9_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_Long * extra10_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Long * extra10_physdatap = ((PDL_Long *)((__privtrans->pdls[14])->data));
	PDL_Long   extra10_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_Long * extra11_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_Long * extra11_physdatap = ((PDL_Long *)((__privtrans->pdls[15])->data));
	PDL_Long   extra11_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_Long * extra12_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_Long * extra12_physdatap = ((PDL_Long *)((__privtrans->pdls[16])->data));
	PDL_Long   extra12_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_Long * extra13_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_Long * extra13_physdatap = ((PDL_Long *)((__privtrans->pdls[17])->data));
	PDL_Long   extra13_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_Long * extra14_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_Long * extra14_physdatap = ((PDL_Long *)((__privtrans->pdls[18])->data));
	PDL_Long   extra14_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_Long * extra15_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_Long * extra15_physdatap = ((PDL_Long *)((__privtrans->pdls[19])->data));
	PDL_Long   extra15_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_Long * extra16_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_Long * extra16_physdatap = ((PDL_Long *)((__privtrans->pdls[20])->data));
	PDL_Long   extra16_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_Long * extra17_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_Long * extra17_physdatap = ((PDL_Long *)((__privtrans->pdls[21])->data));
	PDL_Long   extra17_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_Long * extra18_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_Long * extra18_physdatap = ((PDL_Long *)((__privtrans->pdls[22])->data));
	PDL_Long   extra18_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_Long * extra19_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_Long * extra19_physdatap = ((PDL_Long *)((__privtrans->pdls[23])->data));
	PDL_Long   extra19_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_Long * min_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_Long * min_physdatap = ((PDL_Long *)((__privtrans->pdls[24])->data));
	PDL_Long   min_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_Long * max_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_Long * max_physdatap = ((PDL_Long *)((__privtrans->pdls[25])->data));
	PDL_Long   max_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_Long min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_LL: {
	PDL_LongLong * min_check_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * min_check_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));
	PDL_LongLong   min_check_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_LongLong * max_check_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * max_check_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));
	PDL_LongLong   max_check_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_LongLong * extra0_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_LongLong * extra0_physdatap = ((PDL_LongLong *)((__privtrans->pdls[4])->data));
	PDL_LongLong   extra0_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_LongLong * extra1_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_LongLong * extra1_physdatap = ((PDL_LongLong *)((__privtrans->pdls[5])->data));
	PDL_LongLong   extra1_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_LongLong * extra2_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_LongLong * extra2_physdatap = ((PDL_LongLong *)((__privtrans->pdls[6])->data));
	PDL_LongLong   extra2_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_LongLong * extra3_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_LongLong * extra3_physdatap = ((PDL_LongLong *)((__privtrans->pdls[7])->data));
	PDL_LongLong   extra3_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_LongLong * extra4_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_LongLong * extra4_physdatap = ((PDL_LongLong *)((__privtrans->pdls[8])->data));
	PDL_LongLong   extra4_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_LongLong * extra5_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_LongLong * extra5_physdatap = ((PDL_LongLong *)((__privtrans->pdls[9])->data));
	PDL_LongLong   extra5_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_LongLong * extra6_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_LongLong * extra6_physdatap = ((PDL_LongLong *)((__privtrans->pdls[10])->data));
	PDL_LongLong   extra6_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_LongLong * extra7_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_LongLong * extra7_physdatap = ((PDL_LongLong *)((__privtrans->pdls[11])->data));
	PDL_LongLong   extra7_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_LongLong * extra8_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_LongLong * extra8_physdatap = ((PDL_LongLong *)((__privtrans->pdls[12])->data));
	PDL_LongLong   extra8_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_LongLong * extra9_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_LongLong * extra9_physdatap = ((PDL_LongLong *)((__privtrans->pdls[13])->data));
	PDL_LongLong   extra9_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_LongLong * extra10_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_LongLong * extra10_physdatap = ((PDL_LongLong *)((__privtrans->pdls[14])->data));
	PDL_LongLong   extra10_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_LongLong * extra11_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_LongLong * extra11_physdatap = ((PDL_LongLong *)((__privtrans->pdls[15])->data));
	PDL_LongLong   extra11_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_LongLong * extra12_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_LongLong * extra12_physdatap = ((PDL_LongLong *)((__privtrans->pdls[16])->data));
	PDL_LongLong   extra12_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_LongLong * extra13_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_LongLong * extra13_physdatap = ((PDL_LongLong *)((__privtrans->pdls[17])->data));
	PDL_LongLong   extra13_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_LongLong * extra14_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_LongLong * extra14_physdatap = ((PDL_LongLong *)((__privtrans->pdls[18])->data));
	PDL_LongLong   extra14_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_LongLong * extra15_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_LongLong * extra15_physdatap = ((PDL_LongLong *)((__privtrans->pdls[19])->data));
	PDL_LongLong   extra15_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_LongLong * extra16_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_LongLong * extra16_physdatap = ((PDL_LongLong *)((__privtrans->pdls[20])->data));
	PDL_LongLong   extra16_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_LongLong * extra17_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_LongLong * extra17_physdatap = ((PDL_LongLong *)((__privtrans->pdls[21])->data));
	PDL_LongLong   extra17_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_LongLong * extra18_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_LongLong * extra18_physdatap = ((PDL_LongLong *)((__privtrans->pdls[22])->data));
	PDL_LongLong   extra18_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_LongLong * extra19_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_LongLong * extra19_physdatap = ((PDL_LongLong *)((__privtrans->pdls[23])->data));
	PDL_LongLong   extra19_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_LongLong * min_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_LongLong * min_physdatap = ((PDL_LongLong *)((__privtrans->pdls[24])->data));
	PDL_LongLong   min_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_LongLong * max_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_LongLong * max_physdatap = ((PDL_LongLong *)((__privtrans->pdls[25])->data));
	PDL_LongLong   max_badval = (PDL_LongLong) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_LongLong min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_F: {
	PDL_Float * min_check_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * min_check_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));
	PDL_Float   min_check_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Float * max_check_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * max_check_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));
	PDL_Float   max_check_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Float * extra0_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Float * extra0_physdatap = ((PDL_Float *)((__privtrans->pdls[4])->data));
	PDL_Float   extra0_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Float * extra1_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Float * extra1_physdatap = ((PDL_Float *)((__privtrans->pdls[5])->data));
	PDL_Float   extra1_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_Float * extra2_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Float * extra2_physdatap = ((PDL_Float *)((__privtrans->pdls[6])->data));
	PDL_Float   extra2_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_Float * extra3_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Float * extra3_physdatap = ((PDL_Float *)((__privtrans->pdls[7])->data));
	PDL_Float   extra3_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_Float * extra4_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Float * extra4_physdatap = ((PDL_Float *)((__privtrans->pdls[8])->data));
	PDL_Float   extra4_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_Float * extra5_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Float * extra5_physdatap = ((PDL_Float *)((__privtrans->pdls[9])->data));
	PDL_Float   extra5_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_Float * extra6_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Float * extra6_physdatap = ((PDL_Float *)((__privtrans->pdls[10])->data));
	PDL_Float   extra6_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_Float * extra7_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Float * extra7_physdatap = ((PDL_Float *)((__privtrans->pdls[11])->data));
	PDL_Float   extra7_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_Float * extra8_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Float * extra8_physdatap = ((PDL_Float *)((__privtrans->pdls[12])->data));
	PDL_Float   extra8_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_Float * extra9_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Float * extra9_physdatap = ((PDL_Float *)((__privtrans->pdls[13])->data));
	PDL_Float   extra9_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_Float * extra10_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Float * extra10_physdatap = ((PDL_Float *)((__privtrans->pdls[14])->data));
	PDL_Float   extra10_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_Float * extra11_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_Float * extra11_physdatap = ((PDL_Float *)((__privtrans->pdls[15])->data));
	PDL_Float   extra11_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_Float * extra12_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_Float * extra12_physdatap = ((PDL_Float *)((__privtrans->pdls[16])->data));
	PDL_Float   extra12_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_Float * extra13_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_Float * extra13_physdatap = ((PDL_Float *)((__privtrans->pdls[17])->data));
	PDL_Float   extra13_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_Float * extra14_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_Float * extra14_physdatap = ((PDL_Float *)((__privtrans->pdls[18])->data));
	PDL_Float   extra14_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_Float * extra15_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_Float * extra15_physdatap = ((PDL_Float *)((__privtrans->pdls[19])->data));
	PDL_Float   extra15_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_Float * extra16_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_Float * extra16_physdatap = ((PDL_Float *)((__privtrans->pdls[20])->data));
	PDL_Float   extra16_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_Float * extra17_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_Float * extra17_physdatap = ((PDL_Float *)((__privtrans->pdls[21])->data));
	PDL_Float   extra17_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_Float * extra18_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_Float * extra18_physdatap = ((PDL_Float *)((__privtrans->pdls[22])->data));
	PDL_Float   extra18_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_Float * extra19_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_Float * extra19_physdatap = ((PDL_Float *)((__privtrans->pdls[23])->data));
	PDL_Float   extra19_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_Float * min_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_Float * min_physdatap = ((PDL_Float *)((__privtrans->pdls[24])->data));
	PDL_Float   min_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_Float * max_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_Float * max_physdatap = ((PDL_Float *)((__privtrans->pdls[25])->data));
	PDL_Float   max_badval = (PDL_Float) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_Float min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	} break; case PDL_D: {
	PDL_Double * min_check_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * min_check_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));
	PDL_Double   min_check_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[0]));

	PDL_Long * min_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   min_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[1]));

	PDL_Double * max_check_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * max_check_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));
	PDL_Double   max_check_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[2]));

	PDL_Long * max_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * max_index_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));
	PDL_Long   max_index_badval = (PDL_Long) PDL->get_pdl_badvalue((__privtrans->pdls[3]));

	PDL_Double * extra0_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * extra0_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));
	PDL_Double   extra0_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[4]));

	PDL_Double * extra1_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * extra1_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));
	PDL_Double   extra1_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[5]));

	PDL_Double * extra2_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * extra2_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));
	PDL_Double   extra2_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[6]));

	PDL_Double * extra3_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * extra3_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));
	PDL_Double   extra3_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[7]));

	PDL_Double * extra4_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Double * extra4_physdatap = ((PDL_Double *)((__privtrans->pdls[8])->data));
	PDL_Double   extra4_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[8]));

	PDL_Double * extra5_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * extra5_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));
	PDL_Double   extra5_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[9]));

	PDL_Double * extra6_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[10]),(__privtrans->vtable->per_pdl_flags[10]))));
	PDL_Double * extra6_physdatap = ((PDL_Double *)((__privtrans->pdls[10])->data));
	PDL_Double   extra6_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[10]));

	PDL_Double * extra7_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[11]),(__privtrans->vtable->per_pdl_flags[11]))));
	PDL_Double * extra7_physdatap = ((PDL_Double *)((__privtrans->pdls[11])->data));
	PDL_Double   extra7_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[11]));

	PDL_Double * extra8_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[12]),(__privtrans->vtable->per_pdl_flags[12]))));
	PDL_Double * extra8_physdatap = ((PDL_Double *)((__privtrans->pdls[12])->data));
	PDL_Double   extra8_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[12]));

	PDL_Double * extra9_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[13]),(__privtrans->vtable->per_pdl_flags[13]))));
	PDL_Double * extra9_physdatap = ((PDL_Double *)((__privtrans->pdls[13])->data));
	PDL_Double   extra9_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[13]));

	PDL_Double * extra10_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[14]),(__privtrans->vtable->per_pdl_flags[14]))));
	PDL_Double * extra10_physdatap = ((PDL_Double *)((__privtrans->pdls[14])->data));
	PDL_Double   extra10_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[14]));

	PDL_Double * extra11_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[15]),(__privtrans->vtable->per_pdl_flags[15]))));
	PDL_Double * extra11_physdatap = ((PDL_Double *)((__privtrans->pdls[15])->data));
	PDL_Double   extra11_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[15]));

	PDL_Double * extra12_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[16]),(__privtrans->vtable->per_pdl_flags[16]))));
	PDL_Double * extra12_physdatap = ((PDL_Double *)((__privtrans->pdls[16])->data));
	PDL_Double   extra12_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[16]));

	PDL_Double * extra13_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[17]),(__privtrans->vtable->per_pdl_flags[17]))));
	PDL_Double * extra13_physdatap = ((PDL_Double *)((__privtrans->pdls[17])->data));
	PDL_Double   extra13_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[17]));

	PDL_Double * extra14_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[18]),(__privtrans->vtable->per_pdl_flags[18]))));
	PDL_Double * extra14_physdatap = ((PDL_Double *)((__privtrans->pdls[18])->data));
	PDL_Double   extra14_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[18]));

	PDL_Double * extra15_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[19]),(__privtrans->vtable->per_pdl_flags[19]))));
	PDL_Double * extra15_physdatap = ((PDL_Double *)((__privtrans->pdls[19])->data));
	PDL_Double   extra15_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[19]));

	PDL_Double * extra16_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[20]),(__privtrans->vtable->per_pdl_flags[20]))));
	PDL_Double * extra16_physdatap = ((PDL_Double *)((__privtrans->pdls[20])->data));
	PDL_Double   extra16_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[20]));

	PDL_Double * extra17_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[21]),(__privtrans->vtable->per_pdl_flags[21]))));
	PDL_Double * extra17_physdatap = ((PDL_Double *)((__privtrans->pdls[21])->data));
	PDL_Double   extra17_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[21]));

	PDL_Double * extra18_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[22]),(__privtrans->vtable->per_pdl_flags[22]))));
	PDL_Double * extra18_physdatap = ((PDL_Double *)((__privtrans->pdls[22])->data));
	PDL_Double   extra18_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[22]));

	PDL_Double * extra19_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[23]),(__privtrans->vtable->per_pdl_flags[23]))));
	PDL_Double * extra19_physdatap = ((PDL_Double *)((__privtrans->pdls[23])->data));
	PDL_Double   extra19_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[23]));

	PDL_Double * min_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[24]),(__privtrans->vtable->per_pdl_flags[24]))));
	PDL_Double * min_physdatap = ((PDL_Double *)((__privtrans->pdls[24])->data));
	PDL_Double   min_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[24]));

	PDL_Double * max_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[25]),(__privtrans->vtable->per_pdl_flags[25]))));
	PDL_Double * max_physdatap = ((PDL_Double *)((__privtrans->pdls[25])->data));
	PDL_Double   max_badval = (PDL_Double) PDL->get_pdl_badvalue((__privtrans->pdls[25]));

if ( __privtrans->bvalflag ) { /*** do 'bad' Code ***/
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;

# line 626"lib/PDL/Drawing/Prima/Utils.pm.PL"
		int N_extras, index, N_pixels;
		PDL_Double min_value, max_value;
		N_extras = __privtrans->N_extras;
		N_pixels = __privtrans->__N_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			{/* Open Q */ register int Q;
			for(Q=0; Q<(__Q_size); Q++) {
				/* First check that all the piddles have good values; note
				 * the fall-through!!!! */
				switch(N_extras) {
					case 19:
						min_value = (extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra19_datap)[0+(__inc_extra19_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra19_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 18:
						min_value = (extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra18_datap)[0+(__inc_extra18_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra18_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 17:
						min_value = (extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra17_datap)[0+(__inc_extra17_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra17_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 16:
						min_value = (extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra16_datap)[0+(__inc_extra16_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra16_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 15:
						min_value = (extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra15_datap)[0+(__inc_extra15_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra15_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 14:
						min_value = (extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra14_datap)[0+(__inc_extra14_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra14_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 13:
						min_value = (extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra13_datap)[0+(__inc_extra13_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra13_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 12:
						min_value = (extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra12_datap)[0+(__inc_extra12_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra12_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 11:
						min_value = (extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra11_datap)[0+(__inc_extra11_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra11_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 10:
						min_value = (extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra10_datap)[0+(__inc_extra10_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra10_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 9:
						min_value = (extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra9_datap)[0+(__inc_extra9_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra9_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 8:
						min_value = (extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra8_datap)[0+(__inc_extra8_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra8_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 7:
						min_value = (extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra7_datap)[0+(__inc_extra7_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra7_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 6:
						min_value = (extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra6_datap)[0+(__inc_extra6_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra6_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 5:
						min_value = (extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra5_datap)[0+(__inc_extra5_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra5_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 4:
						min_value = (extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra4_datap)[0+(__inc_extra4_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra4_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 3:
						min_value = (extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra3_datap)[0+(__inc_extra3_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra3_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 2:
						min_value = (extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra2_datap)[0+(__inc_extra2_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra2_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 1:
						min_value = (extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra1_datap)[0+(__inc_extra1_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra1_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					case 0:
						min_value = (extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if ((extra0_datap)[0+(__inc_extra0_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == extra0_badval			/* bad check */
							|| min_value != min_value		/* nan check */
							|| min_value * 0.0 != 0.0)		/* inf check */
							continue;
						
					/* And make sure the index is good */
					default:
						if((min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_index_badval || (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_index_badval) continue;
						min_value = (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						max_value = (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
						if(	   (min_check_datap)[0+(__inc_min_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == min_check_badval			/* bad check */
							|| (max_check_datap)[0+(__inc_max_check_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */  == max_check_badval
							|| min_value != min_value		/* nan check */
							|| max_value != max_value
							|| min_value * 0.0 != 0.0	/* inf check */
							|| max_value * 0.0 != 0.0)
							continue;
				}
				
				/* If we've reached here, we're ready to test the current
				 * min/max against the values, which are guaranteed to hold
				 * min_check and max_check. */
				
				/* First work with the minima */
				/* get the index and cut it off at the maximum (N-1) */
				index = (min_index_datap)[0+(__inc_min_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == min_badval || min_value < (min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(min_datap)[0+(__inc_min_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = min_value;
				
				/* Now work with the maxima */
				index = (max_index_datap)[0+(__inc_max_index_Q*PP_INDTERM(__privtrans->__Q_size, Q))] /* ACCESS() */ ;
				if (index >= N_pixels) index = N_pixels-1;
				if (index < 0) index = 0;
				if((max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  == max_badval || max_value > (max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */ )
					(max_datap)[0+(__inc_max_N*PP_INDTERM(__privtrans->__N_size, index))] /* ACCESS() */  = max_value;
			}} /* Close Q */
			/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}} else { /*** else do 'good' Code ***/
	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc0_6 = __privtrans->__pdlthread.incs[6];register int __tinc0_7 = __privtrans->__pdlthread.incs[7];register int __tinc0_8 = __privtrans->__pdlthread.incs[8];register int __tinc0_9 = __privtrans->__pdlthread.incs[9];register int __tinc0_10 = __privtrans->__pdlthread.incs[10];register int __tinc0_11 = __privtrans->__pdlthread.incs[11];register int __tinc0_12 = __privtrans->__pdlthread.incs[12];register int __tinc0_13 = __privtrans->__pdlthread.incs[13];register int __tinc0_14 = __privtrans->__pdlthread.incs[14];register int __tinc0_15 = __privtrans->__pdlthread.incs[15];register int __tinc0_16 = __privtrans->__pdlthread.incs[16];register int __tinc0_17 = __privtrans->__pdlthread.incs[17];register int __tinc0_18 = __privtrans->__pdlthread.incs[18];register int __tinc0_19 = __privtrans->__pdlthread.incs[19];register int __tinc0_20 = __privtrans->__pdlthread.incs[20];register int __tinc0_21 = __privtrans->__pdlthread.incs[21];register int __tinc0_22 = __privtrans->__pdlthread.incs[22];register int __tinc0_23 = __privtrans->__pdlthread.incs[23];register int __tinc0_24 = __privtrans->__pdlthread.incs[24];register int __tinc0_25 = __privtrans->__pdlthread.incs[25];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];register int __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];register int __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];register int __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];register int __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];register int __tinc1_10 = __privtrans->__pdlthread.incs[__tnpdls+10];register int __tinc1_11 = __privtrans->__pdlthread.incs[__tnpdls+11];register int __tinc1_12 = __privtrans->__pdlthread.incs[__tnpdls+12];register int __tinc1_13 = __privtrans->__pdlthread.incs[__tnpdls+13];register int __tinc1_14 = __privtrans->__pdlthread.incs[__tnpdls+14];register int __tinc1_15 = __privtrans->__pdlthread.incs[__tnpdls+15];register int __tinc1_16 = __privtrans->__pdlthread.incs[__tnpdls+16];register int __tinc1_17 = __privtrans->__pdlthread.incs[__tnpdls+17];register int __tinc1_18 = __privtrans->__pdlthread.incs[__tnpdls+18];register int __tinc1_19 = __privtrans->__pdlthread.incs[__tnpdls+19];register int __tinc1_20 = __privtrans->__pdlthread.incs[__tnpdls+20];register int __tinc1_21 = __privtrans->__pdlthread.incs[__tnpdls+21];register int __tinc1_22 = __privtrans->__pdlthread.incs[__tnpdls+22];register int __tinc1_23 = __privtrans->__pdlthread.incs[__tnpdls+23];register int __tinc1_24 = __privtrans->__pdlthread.incs[__tnpdls+24];register int __tinc1_25 = __privtrans->__pdlthread.incs[__tnpdls+25];min_check_datap += __offsp[0];
min_index_datap += __offsp[1];
max_check_datap += __offsp[2];
max_index_datap += __offsp[3];
extra0_datap += __offsp[4];
extra1_datap += __offsp[5];
extra2_datap += __offsp[6];
extra3_datap += __offsp[7];
extra4_datap += __offsp[8];
extra5_datap += __offsp[9];
extra6_datap += __offsp[10];
extra7_datap += __offsp[11];
extra8_datap += __offsp[12];
extra9_datap += __offsp[13];
extra10_datap += __offsp[14];
extra11_datap += __offsp[15];
extra12_datap += __offsp[16];
extra13_datap += __offsp[17];
extra14_datap += __offsp[18];
extra15_datap += __offsp[19];
extra16_datap += __offsp[20];
extra17_datap += __offsp[21];
extra18_datap += __offsp[22];
extra19_datap += __offsp[23];
min_datap += __offsp[24];
max_datap += __offsp[25];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_extra17_Q = __privtrans->__inc_extra17_Q;
register PDL_Long __inc_extra10_Q = __privtrans->__inc_extra10_Q;
register PDL_Long __inc_extra1_Q = __privtrans->__inc_extra1_Q;
register PDL_Long __inc_max_N = __privtrans->__inc_max_N;
register PDL_Long __inc_extra16_Q = __privtrans->__inc_extra16_Q;
register PDL_Long __inc_min_index_Q = __privtrans->__inc_min_index_Q;
register PDL_Long __inc_min_check_Q = __privtrans->__inc_min_check_Q;
register PDL_Long __inc_extra9_Q = __privtrans->__inc_extra9_Q;
register PDL_Long __inc_extra13_Q = __privtrans->__inc_extra13_Q;
register PDL_Long __inc_extra7_Q = __privtrans->__inc_extra7_Q;
register PDL_Long __inc_max_check_Q = __privtrans->__inc_max_check_Q;
register PDL_Long __inc_extra4_Q = __privtrans->__inc_extra4_Q;
register PDL_Long __inc_max_index_Q = __privtrans->__inc_max_index_Q;
register PDL_Long __inc_extra0_Q = __privtrans->__inc_extra0_Q;
register PDL_Long __inc_extra14_Q = __privtrans->__inc_extra14_Q;
register PDL_Long __inc_extra15_Q = __privtrans->__inc_extra15_Q;
register PDL_Long __inc_extra2_Q = __privtrans->__inc_extra2_Q;
register PDL_Long __inc_min_N = __privtrans->__inc_min_N;
register PDL_Long __inc_extra8_Q = __privtrans->__inc_extra8_Q;
register PDL_Long __inc_extra12_Q = __privtrans->__inc_extra12_Q;
register PDL_Long __inc_extra5_Q = __privtrans->__inc_extra5_Q;
register PDL_Long __inc_extra6_Q = __privtrans->__inc_extra6_Q;
register PDL_Long __inc_extra19_Q = __privtrans->__inc_extra19_Q;
register PDL_Long __inc_extra3_Q = __privtrans->__inc_extra3_Q;
register PDL_Long __inc_extra18_Q = __privtrans->__inc_extra18_Q;
register PDL_Long __inc_extra11_Q = __privtrans->__inc_extra11_Q;


		barf("Internal error: good code should never be called in collate_min_max_for_many");
	
}	/* THREADLOOPEND */
	 min_check_datap += __tinc0_0;
min_index_datap += __tinc0_1;
max_check_datap += __tinc0_2;
max_index_datap += __tinc0_3;
extra0_datap += __tinc0_4;
extra1_datap += __tinc0_5;
extra2_datap += __tinc0_6;
extra3_datap += __tinc0_7;
extra4_datap += __tinc0_8;
extra5_datap += __tinc0_9;
extra6_datap += __tinc0_10;
extra7_datap += __tinc0_11;
extra8_datap += __tinc0_12;
extra9_datap += __tinc0_13;
extra10_datap += __tinc0_14;
extra11_datap += __tinc0_15;
extra12_datap += __tinc0_16;
extra13_datap += __tinc0_17;
extra14_datap += __tinc0_18;
extra15_datap += __tinc0_19;
extra16_datap += __tinc0_20;
extra17_datap += __tinc0_21;
extra18_datap += __tinc0_22;
extra19_datap += __tinc0_23;
min_datap += __tinc0_24;
max_datap += __tinc0_25;

	 } min_check_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
max_check_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
max_index_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
extra0_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
extra1_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;
extra2_datap += __tinc1_6
	     			     - __tinc0_6 *
				       __tdims0;
extra3_datap += __tinc1_7
	     			     - __tinc0_7 *
				       __tdims0;
extra4_datap += __tinc1_8
	     			     - __tinc0_8 *
				       __tdims0;
extra5_datap += __tinc1_9
	     			     - __tinc0_9 *
				       __tdims0;
extra6_datap += __tinc1_10
	     			     - __tinc0_10 *
				       __tdims0;
extra7_datap += __tinc1_11
	     			     - __tinc0_11 *
				       __tdims0;
extra8_datap += __tinc1_12
	     			     - __tinc0_12 *
				       __tdims0;
extra9_datap += __tinc1_13
	     			     - __tinc0_13 *
				       __tdims0;
extra10_datap += __tinc1_14
	     			     - __tinc0_14 *
				       __tdims0;
extra11_datap += __tinc1_15
	     			     - __tinc0_15 *
				       __tdims0;
extra12_datap += __tinc1_16
	     			     - __tinc0_16 *
				       __tdims0;
extra13_datap += __tinc1_17
	     			     - __tinc0_17 *
				       __tdims0;
extra14_datap += __tinc1_18
	     			     - __tinc0_18 *
				       __tdims0;
extra15_datap += __tinc1_19
	     			     - __tinc0_19 *
				       __tdims0;
extra16_datap += __tinc1_20
	     			     - __tinc0_20 *
				       __tdims0;
extra17_datap += __tinc1_21
	     			     - __tinc0_21 *
				       __tdims0;
extra18_datap += __tinc1_22
	     			     - __tinc0_22 *
				       __tdims0;
extra19_datap += __tinc1_23
	     			     - __tinc0_23 *
				       __tdims0;
min_datap += __tinc1_24
	     			     - __tinc0_24 *
				       __tdims0;
max_datap += __tinc1_25
	     			     - __tinc0_25 *
				       __tdims0;

	} min_check_datap -= __tinc1_0 *
     				  __tdims1;min_index_datap -= __tinc1_1 *
     				  __tdims1;max_check_datap -= __tinc1_2 *
     				  __tdims1;max_index_datap -= __tinc1_3 *
     				  __tdims1;extra0_datap -= __tinc1_4 *
     				  __tdims1;extra1_datap -= __tinc1_5 *
     				  __tdims1;extra2_datap -= __tinc1_6 *
     				  __tdims1;extra3_datap -= __tinc1_7 *
     				  __tdims1;extra4_datap -= __tinc1_8 *
     				  __tdims1;extra5_datap -= __tinc1_9 *
     				  __tdims1;extra6_datap -= __tinc1_10 *
     				  __tdims1;extra7_datap -= __tinc1_11 *
     				  __tdims1;extra8_datap -= __tinc1_12 *
     				  __tdims1;extra9_datap -= __tinc1_13 *
     				  __tdims1;extra10_datap -= __tinc1_14 *
     				  __tdims1;extra11_datap -= __tinc1_15 *
     				  __tdims1;extra12_datap -= __tinc1_16 *
     				  __tdims1;extra13_datap -= __tinc1_17 *
     				  __tdims1;extra14_datap -= __tinc1_18 *
     				  __tdims1;extra15_datap -= __tinc1_19 *
     				  __tdims1;extra16_datap -= __tinc1_20 *
     				  __tdims1;extra17_datap -= __tinc1_21 *
     				  __tdims1;extra18_datap -= __tinc1_22 *
     				  __tdims1;extra19_datap -= __tinc1_23 *
     				  __tdims1;min_datap -= __tinc1_24 *
     				  __tdims1;max_datap -= __tinc1_25 *
     				  __tdims1;
 min_check_datap -= __offsp[0];
min_index_datap -= __offsp[1];
max_check_datap -= __offsp[2];
max_index_datap -= __offsp[3];
extra0_datap -= __offsp[4];
extra1_datap -= __offsp[5];
extra2_datap -= __offsp[6];
extra3_datap -= __offsp[7];
extra4_datap -= __offsp[8];
extra5_datap -= __offsp[9];
extra6_datap -= __offsp[10];
extra7_datap -= __offsp[11];
extra8_datap -= __offsp[12];
extra9_datap -= __offsp[13];
extra10_datap -= __offsp[14];
extra11_datap -= __offsp[15];
extra12_datap -= __offsp[16];
extra13_datap -= __offsp[17];
extra14_datap -= __offsp[18];
extra15_datap -= __offsp[19];
extra16_datap -= __offsp[20];
extra17_datap -= __offsp[21];
extra18_datap -= __offsp[22];
extra19_datap -= __offsp[23];
min_datap -= __offsp[24];
max_datap -= __offsp[25];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 }
	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_collate_min_max_wrt_many_free(pdl_trans *__tr ) {
	int __dim;
	pdl_collate_min_max_wrt_many_struct *__privtrans = (pdl_collate_min_max_wrt_many_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_collate_min_max_wrt_many_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_collate_min_max_wrt_many_vtable = {
		0,0, 24, 26, pdl_collate_min_max_wrt_many_vtable_flags,
		pdl_collate_min_max_wrt_many_redodims, pdl_collate_min_max_wrt_many_readdata, NULL,
		pdl_collate_min_max_wrt_many_free,NULL,NULL,pdl_collate_min_max_wrt_many_copy,NULL,
		sizeof(pdl_collate_min_max_wrt_many_struct),"pdl_collate_min_max_wrt_many_vtable",
		NULL
	 };

typedef struct pdl_trim_collated_min_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_minima_m;PDL_Long  __inc_minima_a;PDL_Long  __inc_min_mask_m;PDL_Long  __a_size;PDL_Long  __m_size;
		
		char __ddone; /* Dims done */
		} pdl_trim_collated_min_struct;

void pdl_trim_collated_min_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_min_struct *__privtrans = (pdl_trim_collated_min_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__a_size = 3;
__privtrans->__m_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"minima","min_mask"};
		static int __realdims[] = {2,1};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::trim_collated_min";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__a_size <= 1) __privtrans->__a_size = 1;
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__m_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in trim_collated_min:" "Wrong dims\n");
      }
   }
   if(__privtrans->__a_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__a_size == 1)) {
      __privtrans->__a_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__a_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in trim_collated_min:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__m_size <= 1) __privtrans->__m_size = 1;
   }
   if(__privtrans->__m_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__m_size == 1)) {
      __privtrans->__m_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__m_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in trim_collated_min:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__m_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_minima_m = 0; else
		 __privtrans->__inc_minima_m = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_minima_a = 0; else
		 __privtrans->__inc_minima_a = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_min_mask_m = 0; else
		 __privtrans->__inc_min_mask_m = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_trim_collated_min_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_min_struct *__privtrans = (pdl_trim_collated_min_struct *) __tr;
	
	{
	    pdl_trim_collated_min_struct *__copy = malloc(sizeof(pdl_trim_collated_min_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_minima_m=__copy->__inc_minima_m;__privtrans->__inc_minima_a=__copy->__inc_minima_a;__privtrans->__inc_min_mask_m=__copy->__inc_min_mask_m;__copy->__a_size=__privtrans->__a_size;__copy->__m_size=__privtrans->__m_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_trim_collated_min_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_min_struct *__privtrans = (pdl_trim_collated_min_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * minima_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * minima_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_Byte min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_S: {
	PDL_Short * minima_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * minima_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_Short min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_US: {
	PDL_Ushort * minima_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * minima_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_Ushort min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_L: {
	PDL_Long * minima_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * minima_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_Long min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_LL: {
	PDL_LongLong * minima_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * minima_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_LongLong min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_F: {
	PDL_Float * minima_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * minima_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_Float min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_D: {
	PDL_Double * minima_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * minima_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * min_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * min_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_min_mask_m = __privtrans->__inc_min_mask_m;
register PDL_Long __inc_minima_m = __privtrans->__inc_minima_m;
register PDL_Long __inc_minima_a = __privtrans->__inc_minima_a;


		PDL_Double min;
		int countdown, M;
		M = __privtrans->__m_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];minima_datap += __offsp[0];
min_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, M-1))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, M-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = M-2; countdown >= 0; countdown--) {
				if ((minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  < min) {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 1;
					min = (minima_datap)[0+(__inc_minima_m*PP_INDTERM(__privtrans->__m_size, countdown))+(__inc_minima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(min_mask_datap)[0+(__inc_min_mask_m*PP_INDTERM(__privtrans->__m_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 minima_datap += __tinc0_0;
min_mask_datap += __tinc0_1;

	 } minima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
min_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} minima_datap -= __tinc1_0 *
     				  __tdims1;min_mask_datap -= __tinc1_1 *
     				  __tdims1;
 minima_datap -= __offsp[0];
min_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_trim_collated_min_free(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_min_struct *__privtrans = (pdl_trim_collated_min_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_trim_collated_min_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_trim_collated_min_vtable = {
		0,0, 1, 2, pdl_trim_collated_min_vtable_flags,
		pdl_trim_collated_min_redodims, pdl_trim_collated_min_readdata, NULL,
		pdl_trim_collated_min_free,NULL,NULL,pdl_trim_collated_min_copy,NULL,
		sizeof(pdl_trim_collated_min_struct),"pdl_trim_collated_min_vtable",
		NULL
	 };

typedef struct pdl_trim_collated_max_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_maxima_n;PDL_Long  __inc_maxima_a;PDL_Long  __inc_max_mask_n;PDL_Long  __n_size;PDL_Long  __a_size;
		
		char __ddone; /* Dims done */
		} pdl_trim_collated_max_struct;

void pdl_trim_collated_max_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_max_struct *__privtrans = (pdl_trim_collated_max_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__privtrans->__a_size = 3;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"maxima","max_mask"};
		static int __realdims[] = {2,1};
		static char __funcname[] = "PDL::Drawing::Prima::Utils::trim_collated_max";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags, 
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__a_size <= 1) __privtrans->__a_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in trim_collated_max:" "Wrong dims\n");
      }
   }
   if(__privtrans->__a_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__a_size == 1)) {
      __privtrans->__a_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__a_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in trim_collated_max:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in trim_collated_max:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp && 
	      __privtrans->pdls[0]->hdrsv && 
	 (__privtrans->pdls[0]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp && 
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv && 
	 (__privtrans->pdls[1]->state & PDL_HDRCPY) 
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef) 
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1) 
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");
    
    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)  
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv ); 
	 if( hdr_copy != &PL_sv_undef ) 
             SvREFCNT_inc(hdr_copy); 
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_maxima_n = 0; else
		 __privtrans->__inc_maxima_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_maxima_a = 0; else
		 __privtrans->__inc_maxima_a = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_max_mask_n = 0; else
		 __privtrans->__inc_max_mask_n = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_trim_collated_max_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_max_struct *__privtrans = (pdl_trim_collated_max_struct *) __tr;
	
	{
	    pdl_trim_collated_max_struct *__copy = malloc(sizeof(pdl_trim_collated_max_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_maxima_n=__copy->__inc_maxima_n;__privtrans->__inc_maxima_a=__copy->__inc_maxima_a;__privtrans->__inc_max_mask_n=__copy->__inc_max_mask_n;__copy->__n_size=__privtrans->__n_size;__copy->__a_size=__privtrans->__a_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_trim_collated_max_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_max_struct *__privtrans = (pdl_trim_collated_max_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * maxima_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * maxima_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_Byte max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_S: {
	PDL_Short * maxima_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * maxima_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_Short max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_US: {
	PDL_Ushort * maxima_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * maxima_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_Ushort max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_L: {
	PDL_Long * maxima_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * maxima_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_Long max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_LL: {
	PDL_LongLong * maxima_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * maxima_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_LongLong max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_F: {
	PDL_Float * maxima_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * maxima_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_Float max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_D: {
	PDL_Double * maxima_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * maxima_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * max_mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * max_mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_max_mask_n = __privtrans->__inc_max_mask_n;
register PDL_Long __inc_maxima_n = __privtrans->__inc_maxima_n;
register PDL_Long __inc_maxima_a = __privtrans->__inc_maxima_a;


		PDL_Double max;
		int countdown, N;
		N = __privtrans->__n_size;
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];maxima_datap += __offsp[0];
max_mask_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, N-1))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
			
			/* Always keep the highest one */
			(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, N-1))] /* ACCESS() */  = 1;
			
			/* Run through, from the top to the bottom, */
			for (countdown = N-2; countdown >= 0; countdown--) {
				if ((maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */  > max ) {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 1;
					max = (maxima_datap)[0+(__inc_maxima_n*PP_INDTERM(__privtrans->__n_size, countdown))+(__inc_maxima_a*PP_INDTERM(__privtrans->__a_size, 2))] /* ACCESS() */ ;
				}
				else {
					(max_mask_datap)[0+(__inc_max_mask_n*PP_INDTERM(__privtrans->__n_size, countdown))] /* ACCESS() */  = 0;
				}
			}
			/* THREADLOOPEND */
	 maxima_datap += __tinc0_0;
max_mask_datap += __tinc0_1;

	 } maxima_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
max_mask_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} maxima_datap -= __tinc1_0 *
     				  __tdims1;max_mask_datap -= __tinc1_1 *
     				  __tdims1;
 maxima_datap -= __offsp[0];
max_mask_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_trim_collated_max_free(pdl_trans *__tr ) {
	int __dim;
	pdl_trim_collated_max_struct *__privtrans = (pdl_trim_collated_max_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_trim_collated_max_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_trim_collated_max_vtable = {
		0,0, 1, 2, pdl_trim_collated_max_vtable_flags,
		pdl_trim_collated_max_redodims, pdl_trim_collated_max_readdata, NULL,
		pdl_trim_collated_max_free,NULL,NULL,pdl_trim_collated_max_copy,NULL,
		sizeof(pdl_trim_collated_max_struct),"pdl_trim_collated_max_vtable",
		NULL
	 };



#line 14803 "lib/PDL/Drawing/Prima/Utils.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 14855 "lib/PDL/Drawing/Prima/Utils.c"

XS(XS_PDL__Drawing__Prima__Utils_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL__Drawing__Prima__Utils_set_debugging)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 14801 "lib/PDL/Drawing/Prima/Utils.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 14874 "lib/PDL/Drawing/Prima/Utils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_PDL__Drawing__Prima__Utils_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL__Drawing__Prima__Utils_set_boundscheck)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0));
	int	RETVAL;
	dXSTARG;
#line 14810 "lib/PDL/Drawing/Prima/Utils.xs"
       if (! 1)
         warn("Bounds checking is disabled for PDL::Drawing::Prima::Utils");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 14900 "lib/PDL/Drawing/Prima/Utils.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_PDL_color_to_rgb); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_color_to_rgb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 14824 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *rgb_SV;
  pdl  *color;
  pdl  *rgb;
#line 14928 "lib/PDL/Drawing/Prima/Utils.c"
#line 14833 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    color = PDL->SvPDLV(ST(0));
    rgb = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    color = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       rgb_SV = sv_newmortal();
       rgb = PDL->null();
       PDL->SetSV_PDL(rgb_SV,rgb);
       if (bless_stash) rgb_SV = sv_bless(rgb_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       rgb_SV = POPs;
       PUTBACK;
       rgb = PDL->SvPDLV(rgb_SV);
    }
  }
  else {
    croak ("Usage:  PDL::color_to_rgb(color,rgb) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_color_to_rgb_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_color_to_rgb_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((color->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != color->datatype) {
	     color = PDL->get_convertedpdl(color,PDL_L);
	  }if( (rgb->state & PDL_NOMYDIMS) && rgb->trans == NULL ) {
	     rgb->datatype = PDL_L;
	  } else if(PDL_L != rgb->datatype) {
	     rgb = PDL->get_convertedpdl(rgb,PDL_L);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = color;
__privtrans->pdls[1] = rgb;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  rgb->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = rgb_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15008 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_rgb_to_color); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_rgb_to_color)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 14915 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *color_SV;
  pdl  *rgb;
  pdl  *color;
#line 15036 "lib/PDL/Drawing/Prima/Utils.c"
#line 14924 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    rgb = PDL->SvPDLV(ST(0));
    color = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    rgb = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       color_SV = sv_newmortal();
       color = PDL->null();
       PDL->SetSV_PDL(color_SV,color);
       if (bless_stash) color_SV = sv_bless(color_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       color_SV = POPs;
       PUTBACK;
       color = PDL->SvPDLV(color_SV);
    }
  }
  else {
    croak ("Usage:  PDL::rgb_to_color(rgb,color) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_rgb_to_color_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_rgb_to_color_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((rgb->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != rgb->datatype) {
	     rgb = PDL->get_convertedpdl(rgb,PDL_L);
	  }if( (color->state & PDL_NOMYDIMS) && color->trans == NULL ) {
	     color->datatype = PDL_L;
	  } else if(PDL_L != color->datatype) {
	     color = PDL->get_convertedpdl(color,PDL_L);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = rgb;
__privtrans->pdls[1] = color;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  color->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = color_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15116 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_hsv_to_rgb); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_hsv_to_rgb)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 15006 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *rgb_SV;
  pdl  *hsv;
  pdl  *rgb;
#line 15144 "lib/PDL/Drawing/Prima/Utils.c"
#line 15015 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    hsv = PDL->SvPDLV(ST(0));
    rgb = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    hsv = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       rgb_SV = sv_newmortal();
       rgb = PDL->null();
       PDL->SetSV_PDL(rgb_SV,rgb);
       if (bless_stash) rgb_SV = sv_bless(rgb_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       rgb_SV = POPs;
       PUTBACK;
       rgb = PDL->SvPDLV(rgb_SV);
    }
  }
  else {
    croak ("Usage:  PDL::hsv_to_rgb(hsv,rgb) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_hsv_to_rgb_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_hsv_to_rgb_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((hsv->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDLMAX(PDL_F,__privtrans->__datatype) != hsv->datatype) {
	     hsv = PDL->get_convertedpdl(hsv,PDLMAX(PDL_F,__privtrans->__datatype));
	  }if( (rgb->state & PDL_NOMYDIMS) && rgb->trans == NULL ) {
	     rgb->datatype = PDL_L;
	  } else if(PDL_L != rgb->datatype) {
	     rgb = PDL->get_convertedpdl(rgb,PDL_L);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = hsv;
__privtrans->pdls[1] = rgb;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  rgb->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = rgb_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15224 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_rgb_to_hsv); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_rgb_to_hsv)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 15097 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *hsv_SV;
  pdl  *rgb;
  pdl  *hsv;
#line 15252 "lib/PDL/Drawing/Prima/Utils.c"
#line 15106 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    rgb = PDL->SvPDLV(ST(0));
    hsv = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    rgb = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       hsv_SV = sv_newmortal();
       hsv = PDL->null();
       PDL->SetSV_PDL(hsv_SV,hsv);
       if (bless_stash) hsv_SV = sv_bless(hsv_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       hsv_SV = POPs;
       PUTBACK;
       hsv = PDL->SvPDLV(hsv_SV);
    }
  }
  else {
    croak ("Usage:  PDL::rgb_to_hsv(rgb,hsv) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_rgb_to_hsv_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_rgb_to_hsv_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((rgb->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != rgb->datatype) {
	     rgb = PDL->get_convertedpdl(rgb,PDL_L);
	  }if( (hsv->state & PDL_NOMYDIMS) && hsv->trans == NULL ) {
	     hsv->datatype = PDLMAX(PDL_F,__privtrans->__datatype);
	  } else if(PDLMAX(PDL_F,__privtrans->__datatype) != hsv->datatype) {
	     hsv = PDL->get_convertedpdl(hsv,PDLMAX(PDL_F,__privtrans->__datatype));
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = rgb;
__privtrans->pdls[1] = hsv;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  hsv->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = hsv_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15332 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_minmaxforpair); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_minmaxforpair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 15188 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *min_x_SV;
  SV *min_y_SV;
  SV *max_x_SV;
  SV *max_y_SV;
  pdl  *x;
  pdl  *y;
  pdl  *min_x;
  pdl  *min_y;
  pdl  *max_x;
  pdl  *max_y;
#line 15367 "lib/PDL/Drawing/Prima/Utils.c"
#line 15204 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 6) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    min_x = PDL->SvPDLV(ST(2));
    min_y = PDL->SvPDLV(ST(3));
    max_x = PDL->SvPDLV(ST(4));
    max_y = PDL->SvPDLV(ST(5));
  }
  else if (items == 2) { /* only input variables on stack, create outputs and temps */
    nreturn = 4;
    x = PDL->SvPDLV(ST(0));
    y = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       min_x_SV = sv_newmortal();
       min_x = PDL->null();
       PDL->SetSV_PDL(min_x_SV,min_x);
       if (bless_stash) min_x_SV = sv_bless(min_x_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       min_x_SV = POPs;
       PUTBACK;
       min_x = PDL->SvPDLV(min_x_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       min_y_SV = sv_newmortal();
       min_y = PDL->null();
       PDL->SetSV_PDL(min_y_SV,min_y);
       if (bless_stash) min_y_SV = sv_bless(min_y_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       min_y_SV = POPs;
       PUTBACK;
       min_y = PDL->SvPDLV(min_y_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       max_x_SV = sv_newmortal();
       max_x = PDL->null();
       PDL->SetSV_PDL(max_x_SV,max_x);
       if (bless_stash) max_x_SV = sv_bless(max_x_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       max_x_SV = POPs;
       PUTBACK;
       max_x = PDL->SvPDLV(max_x_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       max_y_SV = sv_newmortal();
       max_y = PDL->null();
       PDL->SetSV_PDL(max_y_SV,max_y);
       if (bless_stash) max_y_SV = sv_bless(max_y_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       max_y_SV = POPs;
       PUTBACK;
       max_y = PDL->SvPDLV(max_y_SV);
    }
  }
  else {
    croak ("Usage:  PDL::minmaxforpair(x,y,min_x,min_y,max_x,max_y) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_minmaxforpair_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_minmaxforpair_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((x->state & PDL_BADVAL) > 0) || ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < x->datatype) {
		 	__privtrans->__datatype = x->datatype;
		    }
if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((min_x->state & PDL_NOMYDIMS) &&
		       min_x->trans == NULL) && __privtrans->__datatype < min_x->datatype) {
		 	__privtrans->__datatype = min_x->datatype;
		    }
if(!((min_y->state & PDL_NOMYDIMS) &&
		       min_y->trans == NULL) && __privtrans->__datatype < min_y->datatype) {
		 	__privtrans->__datatype = min_y->datatype;
		    }
if(!((max_x->state & PDL_NOMYDIMS) &&
		       max_x->trans == NULL) && __privtrans->__datatype < max_x->datatype) {
		 	__privtrans->__datatype = max_x->datatype;
		    }
if(!((max_y->state & PDL_NOMYDIMS) &&
		       max_y->trans == NULL) && __privtrans->__datatype < max_y->datatype) {
		 	__privtrans->__datatype = max_y->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != x->datatype) {
	     x = PDL->get_convertedpdl(x,__privtrans->__datatype);
	  }if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (min_x->state & PDL_NOMYDIMS) && min_x->trans == NULL ) {
	     min_x->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != min_x->datatype) {
	     min_x = PDL->get_convertedpdl(min_x,__privtrans->__datatype);
	  }if( (min_y->state & PDL_NOMYDIMS) && min_y->trans == NULL ) {
	     min_y->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != min_y->datatype) {
	     min_y = PDL->get_convertedpdl(min_y,__privtrans->__datatype);
	  }if( (max_x->state & PDL_NOMYDIMS) && max_x->trans == NULL ) {
	     max_x->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != max_x->datatype) {
	     max_x = PDL->get_convertedpdl(max_x,__privtrans->__datatype);
	  }if( (max_y->state & PDL_NOMYDIMS) && max_y->trans == NULL ) {
	     max_y->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != max_y->datatype) {
	     max_y = PDL->get_convertedpdl(max_y,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = x;
__privtrans->pdls[1] = y;
__privtrans->pdls[2] = min_x;
__privtrans->pdls[3] = min_y;
__privtrans->pdls[4] = max_x;
__privtrans->pdls[5] = max_y;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  min_x->state |= PDL_BADVAL;
  min_y->state |= PDL_BADVAL;
  max_x->state |= PDL_BADVAL;
  max_y->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = min_x_SV;
  ST(1) = min_y_SV;
  ST(2) = max_x_SV;
  ST(3) = max_y_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15543 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL__collate_min_max_wrt_many_int); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL__collate_min_max_wrt_many_int)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 27)
       croak_xs_usage(cv,  "min_check, min_index, max_check, max_index, extra0, extra1, extra2, extra3, extra4, extra5, extra6, extra7, extra8, extra9, extra10, extra11, extra12, extra13, extra14, extra15, extra16, extra17, extra18, extra19, min, max, N_extras");
    {
	pdl *	min_check = PDL->SvPDLV(ST(0));
	pdl *	min_index = PDL->SvPDLV(ST(1));
	pdl *	max_check = PDL->SvPDLV(ST(2));
	pdl *	max_index = PDL->SvPDLV(ST(3));
	pdl *	extra0 = PDL->SvPDLV(ST(4));
	pdl *	extra1 = PDL->SvPDLV(ST(5));
	pdl *	extra2 = PDL->SvPDLV(ST(6));
	pdl *	extra3 = PDL->SvPDLV(ST(7));
	pdl *	extra4 = PDL->SvPDLV(ST(8));
	pdl *	extra5 = PDL->SvPDLV(ST(9));
	pdl *	extra6 = PDL->SvPDLV(ST(10));
	pdl *	extra7 = PDL->SvPDLV(ST(11));
	pdl *	extra8 = PDL->SvPDLV(ST(12));
	pdl *	extra9 = PDL->SvPDLV(ST(13));
	pdl *	extra10 = PDL->SvPDLV(ST(14));
	pdl *	extra11 = PDL->SvPDLV(ST(15));
	pdl *	extra12 = PDL->SvPDLV(ST(16));
	pdl *	extra13 = PDL->SvPDLV(ST(17));
	pdl *	extra14 = PDL->SvPDLV(ST(18));
	pdl *	extra15 = PDL->SvPDLV(ST(19));
	pdl *	extra16 = PDL->SvPDLV(ST(20));
	pdl *	extra17 = PDL->SvPDLV(ST(21));
	pdl *	extra18 = PDL->SvPDLV(ST(22));
	pdl *	extra19 = PDL->SvPDLV(ST(23));
	pdl *	min = PDL->SvPDLV(ST(24));
	pdl *	max = PDL->SvPDLV(ST(25));
	int	N_extras = (int)SvIV(ST(26));
#line 15409 "lib/PDL/Drawing/Prima/Utils.xs"
 { pdl_collate_min_max_wrt_many_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_collate_min_max_wrt_many_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((min_check->state & PDL_BADVAL) > 0) || ((min_index->state & PDL_BADVAL) > 0) || ((max_check->state & PDL_BADVAL) > 0) || ((max_index->state & PDL_BADVAL) > 0) || ((extra0->state & PDL_BADVAL) > 0) || ((extra1->state & PDL_BADVAL) > 0) || ((extra2->state & PDL_BADVAL) > 0) || ((extra3->state & PDL_BADVAL) > 0) || ((extra4->state & PDL_BADVAL) > 0) || ((extra5->state & PDL_BADVAL) > 0) || ((extra6->state & PDL_BADVAL) > 0) || ((extra7->state & PDL_BADVAL) > 0) || ((extra8->state & PDL_BADVAL) > 0) || ((extra9->state & PDL_BADVAL) > 0) || ((extra10->state & PDL_BADVAL) > 0) || ((extra11->state & PDL_BADVAL) > 0) || ((extra12->state & PDL_BADVAL) > 0) || ((extra13->state & PDL_BADVAL) > 0) || ((extra14->state & PDL_BADVAL) > 0) || ((extra15->state & PDL_BADVAL) > 0) || ((extra16->state & PDL_BADVAL) > 0) || ((extra17->state & PDL_BADVAL) > 0) || ((extra18->state & PDL_BADVAL) > 0) || ((extra19->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < min_check->datatype) {
		 	__privtrans->__datatype = min_check->datatype;
		    }
if(__privtrans->__datatype < max_check->datatype) {
		 	__privtrans->__datatype = max_check->datatype;
		    }
if(__privtrans->__datatype < extra0->datatype) {
		 	__privtrans->__datatype = extra0->datatype;
		    }
if(__privtrans->__datatype < extra1->datatype) {
		 	__privtrans->__datatype = extra1->datatype;
		    }
if(__privtrans->__datatype < extra2->datatype) {
		 	__privtrans->__datatype = extra2->datatype;
		    }
if(__privtrans->__datatype < extra3->datatype) {
		 	__privtrans->__datatype = extra3->datatype;
		    }
if(__privtrans->__datatype < extra4->datatype) {
		 	__privtrans->__datatype = extra4->datatype;
		    }
if(__privtrans->__datatype < extra5->datatype) {
		 	__privtrans->__datatype = extra5->datatype;
		    }
if(__privtrans->__datatype < extra6->datatype) {
		 	__privtrans->__datatype = extra6->datatype;
		    }
if(__privtrans->__datatype < extra7->datatype) {
		 	__privtrans->__datatype = extra7->datatype;
		    }
if(__privtrans->__datatype < extra8->datatype) {
		 	__privtrans->__datatype = extra8->datatype;
		    }
if(__privtrans->__datatype < extra9->datatype) {
		 	__privtrans->__datatype = extra9->datatype;
		    }
if(__privtrans->__datatype < extra10->datatype) {
		 	__privtrans->__datatype = extra10->datatype;
		    }
if(__privtrans->__datatype < extra11->datatype) {
		 	__privtrans->__datatype = extra11->datatype;
		    }
if(__privtrans->__datatype < extra12->datatype) {
		 	__privtrans->__datatype = extra12->datatype;
		    }
if(__privtrans->__datatype < extra13->datatype) {
		 	__privtrans->__datatype = extra13->datatype;
		    }
if(__privtrans->__datatype < extra14->datatype) {
		 	__privtrans->__datatype = extra14->datatype;
		    }
if(__privtrans->__datatype < extra15->datatype) {
		 	__privtrans->__datatype = extra15->datatype;
		    }
if(__privtrans->__datatype < extra16->datatype) {
		 	__privtrans->__datatype = extra16->datatype;
		    }
if(__privtrans->__datatype < extra17->datatype) {
		 	__privtrans->__datatype = extra17->datatype;
		    }
if(__privtrans->__datatype < extra18->datatype) {
		 	__privtrans->__datatype = extra18->datatype;
		    }
if(__privtrans->__datatype < extra19->datatype) {
		 	__privtrans->__datatype = extra19->datatype;
		    }
if(!((min->state & PDL_NOMYDIMS) &&
		       min->trans == NULL) && __privtrans->__datatype < min->datatype) {
		 	__privtrans->__datatype = min->datatype;
		    }
if(!((max->state & PDL_NOMYDIMS) &&
		       max->trans == NULL) && __privtrans->__datatype < max->datatype) {
		 	__privtrans->__datatype = max->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != min_check->datatype) {
	     min_check = PDL->get_convertedpdl(min_check,__privtrans->__datatype);
	  }if(PDL_L != min_index->datatype) {
	     min_index = PDL->get_convertedpdl(min_index,PDL_L);
	  }if(__privtrans->__datatype != max_check->datatype) {
	     max_check = PDL->get_convertedpdl(max_check,__privtrans->__datatype);
	  }if(PDL_L != max_index->datatype) {
	     max_index = PDL->get_convertedpdl(max_index,PDL_L);
	  }if(__privtrans->__datatype != extra0->datatype) {
	     extra0 = PDL->get_convertedpdl(extra0,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra1->datatype) {
	     extra1 = PDL->get_convertedpdl(extra1,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra2->datatype) {
	     extra2 = PDL->get_convertedpdl(extra2,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra3->datatype) {
	     extra3 = PDL->get_convertedpdl(extra3,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra4->datatype) {
	     extra4 = PDL->get_convertedpdl(extra4,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra5->datatype) {
	     extra5 = PDL->get_convertedpdl(extra5,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra6->datatype) {
	     extra6 = PDL->get_convertedpdl(extra6,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra7->datatype) {
	     extra7 = PDL->get_convertedpdl(extra7,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra8->datatype) {
	     extra8 = PDL->get_convertedpdl(extra8,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra9->datatype) {
	     extra9 = PDL->get_convertedpdl(extra9,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra10->datatype) {
	     extra10 = PDL->get_convertedpdl(extra10,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra11->datatype) {
	     extra11 = PDL->get_convertedpdl(extra11,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra12->datatype) {
	     extra12 = PDL->get_convertedpdl(extra12,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra13->datatype) {
	     extra13 = PDL->get_convertedpdl(extra13,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra14->datatype) {
	     extra14 = PDL->get_convertedpdl(extra14,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra15->datatype) {
	     extra15 = PDL->get_convertedpdl(extra15,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra16->datatype) {
	     extra16 = PDL->get_convertedpdl(extra16,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra17->datatype) {
	     extra17 = PDL->get_convertedpdl(extra17,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra18->datatype) {
	     extra18 = PDL->get_convertedpdl(extra18,__privtrans->__datatype);
	  }if(__privtrans->__datatype != extra19->datatype) {
	     extra19 = PDL->get_convertedpdl(extra19,__privtrans->__datatype);
	  }if( (min->state & PDL_NOMYDIMS) && min->trans == NULL ) {
	     min->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != min->datatype) {
	     min = PDL->get_convertedpdl(min,__privtrans->__datatype);
	  }if( (max->state & PDL_NOMYDIMS) && max->trans == NULL ) {
	     max->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != max->datatype) {
	     max = PDL->get_convertedpdl(max,__privtrans->__datatype);
	  }{(__privtrans->N_extras) = (N_extras);}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = min_check;
__privtrans->pdls[1] = min_index;
__privtrans->pdls[2] = max_check;
__privtrans->pdls[3] = max_index;
__privtrans->pdls[4] = extra0;
__privtrans->pdls[5] = extra1;
__privtrans->pdls[6] = extra2;
__privtrans->pdls[7] = extra3;
__privtrans->pdls[8] = extra4;
__privtrans->pdls[9] = extra5;
__privtrans->pdls[10] = extra6;
__privtrans->pdls[11] = extra7;
__privtrans->pdls[12] = extra8;
__privtrans->pdls[13] = extra9;
__privtrans->pdls[14] = extra10;
__privtrans->pdls[15] = extra11;
__privtrans->pdls[16] = extra12;
__privtrans->pdls[17] = extra13;
__privtrans->pdls[18] = extra14;
__privtrans->pdls[19] = extra15;
__privtrans->pdls[20] = extra16;
__privtrans->pdls[21] = extra17;
__privtrans->pdls[22] = extra18;
__privtrans->pdls[23] = extra19;
__privtrans->pdls[24] = min;
__privtrans->pdls[25] = max;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  min->state |= PDL_BADVAL;
  max->state |= PDL_BADVAL;
}
 XSRETURN(0);
}
#line 15772 "lib/PDL/Drawing/Prima/Utils.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_PDL_trim_collated_min); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_trim_collated_min)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 15596 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *min_mask_SV;
  pdl  *minima;
  pdl  *min_mask;
#line 15799 "lib/PDL/Drawing/Prima/Utils.c"
#line 15605 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    minima = PDL->SvPDLV(ST(0));
    min_mask = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    minima = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       min_mask_SV = sv_newmortal();
       min_mask = PDL->null();
       PDL->SetSV_PDL(min_mask_SV,min_mask);
       if (bless_stash) min_mask_SV = sv_bless(min_mask_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       min_mask_SV = POPs;
       PUTBACK;
       min_mask = PDL->SvPDLV(min_mask_SV);
    }
  }
  else {
    croak ("Usage:  PDL::trim_collated_min(minima,min_mask) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_trim_collated_min_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_trim_collated_min_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((minima->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < minima->datatype) {
		 	__privtrans->__datatype = minima->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != minima->datatype) {
	     minima = PDL->get_convertedpdl(minima,__privtrans->__datatype);
	  }if( (min_mask->state & PDL_NOMYDIMS) && min_mask->trans == NULL ) {
	     min_mask->datatype = PDL_L;
	  } else if(PDL_L != min_mask->datatype) {
	     min_mask = PDL->get_convertedpdl(min_mask,PDL_L);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = minima;
__privtrans->pdls[1] = min_mask;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  min_mask->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = min_mask_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15882 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}


XS(XS_PDL_trim_collated_max); /* prototype to pass -Wmissing-prototypes */
XS(XS_PDL_trim_collated_max)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 15690 "lib/PDL/Drawing/Prima/Utils.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *max_mask_SV;
  pdl  *maxima;
  pdl  *max_mask;
#line 15910 "lib/PDL/Drawing/Prima/Utils.c"
#line 15699 "lib/PDL/Drawing/Prima/Utils.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    maxima = PDL->SvPDLV(ST(0));
    max_mask = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    maxima = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       max_mask_SV = sv_newmortal();
       max_mask = PDL->null();
       PDL->SetSV_PDL(max_mask_SV,max_mask);
       if (bless_stash) max_mask_SV = sv_bless(max_mask_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       max_mask_SV = POPs;
       PUTBACK;
       max_mask = PDL->SvPDLV(max_mask_SV);
    }
  }
  else {
    croak ("Usage:  PDL::trim_collated_max(maxima,max_mask) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_trim_collated_max_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_trim_collated_max_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((maxima->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < maxima->datatype) {
		 	__privtrans->__datatype = maxima->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != maxima->datatype) {
	     maxima = PDL->get_convertedpdl(maxima,__privtrans->__datatype);
	  }if( (max_mask->state & PDL_NOMYDIMS) && max_mask->trans == NULL ) {
	     max_mask->datatype = PDL_L;
	  } else if(PDL_L != max_mask->datatype) {
	     max_mask = PDL->get_convertedpdl(max_mask,PDL_L);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = maxima;
__privtrans->pdls[1] = max_mask;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  max_mask->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = max_mask_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 15993 "lib/PDL/Drawing/Prima/Utils.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_PDL__Drawing__Prima__Utils); /* prototype to pass -Wmissing-prototypes */
XS(boot_PDL__Drawing__Prima__Utils)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("PDL::Drawing::Prima::Utils::set_debugging", XS_PDL__Drawing__Prima__Utils_set_debugging, file, "$");
        (void)newXSproto_portable("PDL::Drawing::Prima::Utils::set_boundscheck", XS_PDL__Drawing__Prima__Utils_set_boundscheck, file, "$");
        (void)newXSproto_portable("PDL::color_to_rgb", XS_PDL_color_to_rgb, file, ";@");
        (void)newXSproto_portable("PDL::rgb_to_color", XS_PDL_rgb_to_color, file, ";@");
        (void)newXSproto_portable("PDL::hsv_to_rgb", XS_PDL_hsv_to_rgb, file, ";@");
        (void)newXSproto_portable("PDL::rgb_to_hsv", XS_PDL_rgb_to_hsv, file, ";@");
        (void)newXSproto_portable("PDL::minmaxforpair", XS_PDL_minmaxforpair, file, ";@");
        (void)newXSproto_portable("PDL::_collate_min_max_wrt_many_int", XS_PDL__collate_min_max_wrt_many_int, file, "$$$$$$$$$$$$$$$$$$$$$$$$$$$");
        (void)newXSproto_portable("PDL::trim_collated_min", XS_PDL_trim_collated_min, file, ";@");
        (void)newXSproto_portable("PDL::trim_collated_max", XS_PDL_trim_collated_max, file, ";@");

    /* Initialisation Section */

#line 15783 "lib/PDL/Drawing/Prima/Utils.xs"

   /* Get pointer to structure of core shared C routines */
   /* make sure PDL::Core is loaded */
   perl_require_pv("PDL::Core");
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
#ifndef aTHX_
#define aTHX_
#endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "Can't load PDL::Core module");
   PDL = INT2PTR(Core*, SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "PDL::Drawing::Prima::Utils needs to be recompiled against the newly installed PDL");

#line 16051 "lib/PDL/Drawing/Prima/Utils.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

